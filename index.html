<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body>


  


<header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Hexo" rel="home"> Hexo </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-Redis跳跃表" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/28/Redis跳跃表/">Redis跳跃表</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/28/Redis跳跃表/" class="article-date">
	  <time datetime="2019-06-28T04:20:38.134Z" itemprop="datePublished">June 28, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><ul>
<li><blockquote>
<p>跳跃表（skiplist）是一种<strong>有序</strong>数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快捷访问节点的目的。</p>
</blockquote>
<p>在大多数情况先，<strong>跳跃表</strong>的效率可以与平衡树媲美，并且因为跳跃表的实现比平衡树更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis使用跳跃表作为<strong>有序集合键</strong>的底层实现之一。</p>
<h2 id="I、跳跃表实现"><a href="#I、跳跃表实现" class="headerlink" title="I、跳跃表实现"></a>I、跳跃表实现</h2><p>Redis的跳跃表由zskiplistNode和zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构用于保存跳跃表节点的相关信息（如节点数量，表头指针，表尾指针等）。</p>
<p>下图为一个跳跃表示意图：</p>
</li>
</ul>
<pre><code>![1561695969873](Redis跳跃表/1561695969873.png)



位于最左边的是zskiplist结构，该结构包含以下属性：
 ·header：指向跳跃表的表头节点。
 ·tail：指向跳跃表的表尾节点。
 ·level：表示目前跳跃表内，层数最大的节点的层数。
 ·length：记录跳跃表长度，即跳跃表包含的节点数量（不包含头结点）。

位于zskiplist结构右方的是四个zskiplistNode结构，其属性如下：
 ·层：用L1、L2、L3等表示节点的各个层，每个层都有两个属性：**前进指针**和**跨度**。前进指针用于访问位于表尾方向的其他节点，跨度记录了前进指针指向节点和当前节点的距离。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。
 ·**后退指针**：节点中用BW表示后退指针，后退指针在程序从表尾向表头遍历时使用。
 · 分值：各个节点中的1.0、2.0是节点保存的分值。**在跳跃表中，节点按照各自所保存的分值从小到大排列**。
 · 成员对象： 各个节点中o1、o2是节点保存的成员对象。

值的注意的是：表头节点和其他节点是不一样的，表头节点也有后退指针、分值和成员对象，但是表头节点的这些属性都不会被用到，所以图中忽略了这一部分。

##### 1.1 跳跃表节点

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line"></span><br><span class="line">    // 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line"></span><br><span class="line">    // 分值</span><br><span class="line">    double score;</span><br><span class="line"></span><br><span class="line">    // 成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    // 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line"></span><br><span class="line">        // 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line"></span><br><span class="line">        // 跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>


**层：**  
 每次创建一个新跳跃表节点的时候，程序都会**随机生成一个介于1和32之间的值作为level数组的大小**，这个大小就是层的“高度”。</code></pre><ul>
<li><img src="/2019/06/28/Redis跳跃表/1561696052378.png" alt="1561696052378"></li>
</ul>
<p><strong>前进指针：</strong><br>每个层都有一个指向表尾方向的前进指针。下图用虚线表示了从表头遍历到表尾的路径：</p>
<p><img src="/2019/06/28/Redis跳跃表/1561696088361.png" alt="1561696088361"></p>
<p><strong>跨度：</strong><br> 层的跨度用于记录两个节点之间的距离：<br> 初看上去，很容易以为跨度与遍历操作有关，但其实<strong>跨度是用来计算排位的</strong>，在查找某个节点的过程中，将沿途访问过的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位。</p>
<p><strong>后退指针：</strong><br> 与每个节点有多个前进指针不同，每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>
<p><strong>分值和成员：</strong><br> 节点的分值用来对所有节点从小到大排序。<br> 节点的成员是一个指针，其指向一个字符串对象，而字符串对象保存着一个SDS值。</p>
<p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：<strong>分值相同的节点将按照成员对象在字典序中的大小进行排序。</strong></p>
<h5 id="1-2-跳跃表"><a href="#1-2-跳跃表" class="headerlink" title="1.2 跳跃表"></a>1.2 跳跃表</h5><p>Redis使用一个zskiplist结构来持有zskiplistNode节点，程序可以更方便的对整个跳跃表进行处理，<strong>比如，快速访问表头节点和表尾节点，或者快速获取表中节点数量。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct zskiplist &#123;</span><br><span class="line"></span><br><span class="line">    // 表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line"></span><br><span class="line">    // 表中节点的数量</span><br><span class="line">    unsigned long length;</span><br><span class="line"></span><br><span class="line">    // 表中层数最大的节点的层数</span><br><span class="line">    int level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<h2 id="II、跳跃表API"><a href="#II、跳跃表API" class="headerlink" title="II、跳跃表API"></a>II、跳跃表API</h2><p><img src="/2019/06/28/Redis跳跃表/1561696136110.png" alt="1561696136110"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-testfeng" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/28/testfeng/">testfeng</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/28/testfeng/" class="article-date">
	  <time datetime="2019-06-28T02:01:47.000Z" itemprop="datePublished">June 28, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2019/06/28/testfeng/1561687357449.png" alt="1561687357449"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(whoami命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/27/一天一个Linux命令(whoami命令)/">一天一个Linux命令(whoami命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/27/一天一个Linux命令(whoami命令)/" class="article-date">
	  <time datetime="2019-06-27T13:10:05.052Z" itemprop="datePublished">June 27, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p> <code>whoami(选项)</code></p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--help：在线帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure>

<h2 id="3、实例"><a href="#3、实例" class="headerlink" title="3、实例"></a>3、实例</h2><p>whoami显示当前用户名， whoami –version 显示当前Linux内核</p>
<pre><code>[fenglangjuxu@localhost ~]$ 
[fenglangjuxu@localhost ~]$ 
[fenglangjuxu@localhost ~]$ whoami
fenglangjuxu
[fenglangjuxu@localhost ~]$ whoami version
whoami: 额外的操作数 &quot;version&quot;
Try &apos;whoami --help&apos; for more information.
[fenglangjuxu@localhost ~]$ whoami --version
whoami (GNU coreutils) 8.22
Copyright (C) 2013 Free Software Foundation, Inc.
许可证：GPLv3+：GNU 通用公共许可证第3 版或更新版本&lt;http://gnu.org/licenses/gpl.html&gt;。
本软件是自由软件：您可以自由修改和重新发布它。
在法律范围内没有其他保证。

由Richard Mlynarik 编写。
[fenglangjuxu@localhost ~]$ </code></pre><p><img src="/2019/06/27/一天一个Linux命令(whoami命令)/1561641280242.png" alt="1561641280242"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Linux/">Linux</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-abc" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/27/abc/">abc</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/27/abc/" class="article-date">
	  <time datetime="2019-06-27T12:41:16.000Z" itemprop="datePublished">June 27, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2019/06/27/abc/1561639397783.png" alt="1561639397783"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(watch命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/26/一天一个Linux命令(watch命令)/">一天一个Linux命令(watch命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/26/一天一个Linux命令(watch命令)/" class="article-date">
	  <time datetime="2019-06-26T14:46:24.632Z" itemprop="datePublished">June 26, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="watch命令"><a href="#watch命令" class="headerlink" title="watch命令"></a>watch命令</h2><ul>
<li><strong>watch命令</strong>以周期性的方式执行给定的指令，指令输出以全屏方式显示。watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>   <code>watch(选项)(参数)</code></p>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n：指定指令执行的间隔时间（秒）；</span><br><span class="line">-d：高亮显示指令输出信息不同之处；</span><br><span class="line">-t：不显示标题。</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><p>指令：需要周期性执行的指令。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> uptime命令用来显示系统运行时间信息,   而watch uptime命令执行后会展示uptime信息：</p>
<p>当前时间   系统连续运行时间  当前用户连接数       系统平均负载（最近2分钟、9分钟、XX分钟）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[fenglangjuxu@localhost ~]$ </span><br><span class="line">[fenglangjuxu@localhost ~]$ </span><br><span class="line">[fenglangjuxu@localhost ~]$ watch uptime</span><br><span class="line">[fenglangjuxu@localhost ~]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Every 2.0s: uptime                                             Thu Jun 27 07:26:42 2019</span><br><span class="line"></span><br><span class="line"> 07:26:42 up 34 min,  2 users,  load average: 0.25, 0.19, 0.47</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(mkdir命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/25/一天一个Linux命令(mkdir命令)/">一天一个Linux命令(mkdir命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/25/一天一个Linux命令(mkdir命令)/" class="article-date">
	  <time datetime="2019-06-25T13:14:55.253Z" itemprop="datePublished">June 25, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><ul>
<li><p><strong>mkdir命令</strong>用来创建目录。该命令创建由<a href="http://man.linuxde.net/dirname" target="_blank" rel="noopener">dirname</a>命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 </p>
<p>注意：在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。</p>
<p>在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。。</p>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>   <code>mkdir (选项)(参数）</code></p>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><pre><code>-Z：设置安全上下文，当使用SELinux时有效；
-m&lt;目标属性&gt;或--mode&lt;目标属性&gt;建立目录的同时设置目录的权限；
-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
--version 显示版本信息。</code></pre><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><p>目录：指定要创建的目录列表，多个目录之间用空格隔开。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>在目录/var/local下建立子目录dongpengju，并且只有文件主有读、写和执行权限，其他人无权访问</p>
<pre><code>drwxr-xr-x.  4 root root   28 6月  22 04:14 target
drwxrwxrwt. 15 root root 4096 6月  26 05:21 tmp
drwxr-xr-x.  2 root root    6 4月  11 2018 yp
[root@localhost var]# cd loc
bash: cd: loc: 没有那个文件或目录
[root@localhost var]# cd loc
local/ lock/  
[root@localhost var]# cd loc
local/ lock/  
[root@localhost var]# cd local/
[root@localhost local]# ll
总用量 0
[root@localhost local]# pwd
/var/local
[root@localhost local]# mkdir -m 700 dongpengju
[root@localhost local]# ll
总用量 0
drwx------. 2 root root 6 6月  26 05:25 dongpengju
[root@localhost local]# </code></pre><p><img src="/2019/06/25/一天一个Linux命令(mkdir命令)/1561687781775.png" alt="1561687781775"></p>
<p>在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问</p>
<pre><code>[root@localhost local]# mkdir -p-m 750 fenglangjuxu/huoqubing
mkdir：无效选项 -- -
Try &apos;mkdir --help&apos; for more information.
[root@localhost local]# mkdir -p -m 750 fenglangjuxu/huoqubing
[root@localhost local]# ll
总用量 0
drwx------. 2 root root  6 6月  26 05:25 dongpengju
drwxr-xr-x. 3 root root 23 6月  26 05:30 fenglangjuxu
[root@localhost local]# </code></pre><p>​    </p>
<p><img src="/2019/06/25/一天一个Linux命令(mkdir命令)/1561469513882.png" alt="1561469513882"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(touch命令) " class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/24/一天一个Linux命令(touch命令) /">一天一个Linux命令(第6天touch命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/24/一天一个Linux命令(touch命令) /" class="article-date">
	  <time datetime="2019-06-24T14:37:32.076Z" itemprop="datePublished">June 24, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><ul>
<li><p><strong>touch命令</strong>有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。</p>
<p>当然了touch主要的功能是用来创建空文件，至少我常用来这么做。</p>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>   <code>touch(选项)(参数)</code></p>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><pre><code>-a：或--time=atime或--time=access或--time=use  只更改存取时间；
-c：或--no-create  不建立任何文件；
-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；
-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；
-m：或--time=mtime或--time=modify  只更该变动时间；
-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；
-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；
--help：在线帮助；
--version：显示版本信息。</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>  创建文件夹dongpengju，可以看到文件夹大小为0，是为空的：</p>
<pre><code>[fenglangjuxu@localhost usr]$ touch dongpengju
touch: 无法创建&quot;dongpengju&quot;: 权限不够
[fenglangjuxu@localhost usr]$ su root
密码：
[root@localhost usr]# pwd
/usr
[root@localhost usr]# touch dongpengju
[root@localhost usr]# ls
bin         etc    include  lib64    local  share  tmp
dongpengju  games  lib      libexec  sbin   src
[root@localhost usr]# ll
总用量 264
dr-xr-xr-x.   2 root root 49152 6月  22 04:37 bin
-rw-r--r--.   1 root root     0 6月  25 06:55 dongpengju
drwxr-xr-x.   2 root root     6 4月  11 2018 etc
drwxr-xr-x.   2 root root     6 4月  11 2018 games
drwxr-xr-x.   9 root root  4096 6月  22 04:34 include
dr-xr-xr-x.  42 root root  4096 6月  22 04:36 lib
dr-xr-xr-x. 142 root root 81920 6月  22 04:39 lib64
drwxr-xr-x.  49 root root 12288 6月  22 04:36 libexec
drwxr-xr-x.  12 root root   131 6月  22 04:07 local
dr-xr-xr-x.   2 root root 20480 6月  22 04:37 sbin
drwxr-xr-x. 235 root root  8192 6月  22 04:37 share
drwxr-xr-x.   4 root root    34 6月  22 04:07 src
lrwxrwxrwx.   1 root root    10 6月  22 04:07 tmp -&gt; ../var/tmp
[root@localhost usr]# </code></pre>
      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(第12天which命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/21/一天一个Linux命令(第12天which命令)/">一天一个Linux命令(第12天which命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/21/一天一个Linux命令(第12天which命令)/" class="article-date">
	  <time datetime="2019-06-21T13:28:04.785Z" itemprop="datePublished">June 21, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h1><ul>
<li><strong>which命令</strong>用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li>
</ul>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p><code>which(选项)(参数)</code></p>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;文件名长度&gt;：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；</span><br><span class="line">-p&lt;文件名长度&gt;：与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径；</span><br><span class="line">-w：指定输出时栏位的宽度；</span><br><span class="line">-V：显示版本信息。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>指令名：指令名列表。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>查找文件、显示命令路径：</p>
<p>zhiruo@luoyang MINGW64 /e/zhiruoblog<br>$</p>
<p>zhiruo@luoyang MINGW64 /e/zhiruoblog<br>$ which ls<br>/usr/bin/ls</p>
<p>zhiruo@luoyang MINGW64 /e/zhiruoblog<br>$ which chmod<br>/usr/bin/chmod</p>
<p>zhiruo@luoyang MINGW64 /e/zhiruoblog<br>$ which pwd<br>/usr/bin/pwd </p>
<p>如图：</p>
<p><img src="/2019/06/21/一天一个Linux命令(第12天which命令)/1561124360712.png" alt="1561124360712"></p>
<p>说明：which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Event-Driven Data Management for Microservices" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	<a href="/2019/06/21/Event-Driven Data Management for Microservices/" class="article-date">
	  <time datetime="2019-06-21T02:23:53.828Z" itemprop="datePublished">June 21, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Event-Driven-Data-Management-for-Microservices-用于微服务的事件驱动数据管理"><a href="#Event-Driven-Data-Management-for-Microservices-用于微服务的事件驱动数据管理" class="headerlink" title="Event-Driven Data Management for Microservices   用于微服务的事件驱动数据管理"></a>Event-Driven Data Management for Microservices   用于微服务的事件驱动数据管理</h1><p><em>Editor – This seven‑part series of articles is now complete:</em></p>
<p><em>编辑－此七部分系列文章现已完成：</em></p>
<ol>
<li><a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="noopener">Introduction to Microservices</a>  微服务构建微服务简介：</li>
<li><a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/" target="_blank" rel="noopener">Building Microservices: Using an API Gateway</a> 使用api网关构建微服务</li>
<li><a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/" target="_blank" rel="noopener">Building Microservices: Inter-Process Communication in a Microservices Architecture</a> 微服务体系结构中的进程间通信</li>
<li><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" target="_blank" rel="noopener">Service Discovery in a Microservices Architecture</a> 微服务体系结构中的服务发现</li>
<li>Event‑Driven Data Management for Microservices (this article) 事件驱动的微服务数据管理(本文)</li>
<li><a href="https://www.nginx.com/blog/deploying-microservices/" target="_blank" rel="noopener">Choosing a Microservices Deployment Strategy</a> 选择一种微服务部署策略</li>
<li><a href="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/" target="_blank" rel="noopener">Refactoring a Monolith into Microservices</a> 将单个微服务重构为微服务。</li>
</ol>
<p><em>You can also download the complete set of articles, plus information about implementing microservices using NGINX Plus, as an ebook – Microservices: From Design to Deployment. And see our series on the Microservices Reference Architecture and the Microservices Solutions page.</em></p>
<p><em>您还可以下载完整的文章集，以及有关使用nginx+实现微服务的信息，作为电子书-microservices：从设计到部署。并在微服务参考体系结构和微服务解决方案页面上查看我们的系列文章。</em> </p>
<p>This is the fifth article in a series about building applications with microservices. The <a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="noopener">first article</a> introduces the Microservices Architecture pattern and discusses the benefits and drawbacks of using microservices. The <a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway" target="_blank" rel="noopener">second</a> and <a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/" target="_blank" rel="noopener">third</a> articles in the series describe different aspects of communication within a microservices architecture. The <a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" target="_blank" rel="noopener">fourth article</a> explores the closely related problem of service discovery. In this article, we change gears and look at the distributed data management problems that arise in a microservices architecture.</p>
<p>这是关于使用微服务构建应用程序的系列文章的第五篇。第一篇文章介绍了微服务体系结构模式，讨论了使用微服务的优缺点。本系列的第二和第三篇文章描述了微服务体系结构中通信的不同方面。第四篇文章探讨了与服务发现密切相关的问题。在本文中，我们改变了方向，并研究了微服务体系结构中出现的分布式数据管理问题。</p>
<h2 id="Microservices-and-the-Problem-of-Distributed-Data-Management-微服务与分布式数据管理问题"><a href="#Microservices-and-the-Problem-of-Distributed-Data-Management-微服务与分布式数据管理问题" class="headerlink" title="Microservices and the Problem of Distributed Data Management 微服务与分布式数据管理问题"></a>Microservices and the Problem of Distributed Data Management 微服务与分布式数据管理问题</h2><p>A monolithic application typically has a single relational database. A key benefit of using a relational database is that your application can use <a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID transactions</a>, which provide some important guarantees:</p>
<p>单块应用程序通常有一个关系数据库。使用关系数据库的一个主要好处是应用程序可以使用ACID事务，这提供了一些重要的保证： </p>
<ul>
<li>Atomicity – Changes are made atomically 原子性-原子化改变 </li>
<li>Consistency – The state of the database is always consistent 一致性-数据库的状态始终一致 </li>
<li>Isolation – Even though transactions are executed concurrently it appears they are executed serially 隔离-即使事务是并发执行的，它们似乎都是串行执行的。 </li>
<li>Durability – Once a transaction has committed it is not undone 持久性-事务一旦提交，就不会撤消。 </li>
</ul>
<p>As a result, your application can simply begin a transaction, change (insert, update, and delete) multiple rows, and commit the transaction.</p>
<p>因此，您的应用程序可以简单地开始事务、更改（插入、更新和删除）多行，并提交事务</p>
<p>Another great benefit of using a relational database is that it provides SQL, which is a rich, declarative, and standardized query language. You can easily write a query that combines data from multiple tables. The RDBMS query planner then determines the most optimal way to execute the query. You don’t have to worry about low‑level details such as how to access the database. And, because all of your application’s data is in one database, it is easy to query.</p>
<p>使用关系数据库的另一个好处是它提供了SQL，它是一个丰富的、声明性的和标准化的查询语言。您可以轻松编写将数据与多个表组合的查询。RDBMS查询规划器然后确定执行查询的最佳方式。您不必担心低级详细信息，例如如何访问数据库。而且，由于所有应用程序的数据都在一个数据库中，因此很容易查询。</p>
<p>Unfortunately, data access becomes much more complex when we move to a microservices architecture. That is because the data owned by each microservice is <a href="http://microservices.io/patterns/data/database-per-service.html" target="_blank" rel="noopener">private to that microservice</a> and can only be accessed via its API. Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another. If multiple services access the same data, schema updates require time‑consuming, coordinated updates to all of the services.</p>
<p>不幸的是，当我们转向微服务体系结构时，数据访问变得更加复杂。这是因为每个微服务拥有的数据都是该微服务的私有数据，并且只能通过其API访问。封装数据可以确保微服务是松散耦合的，并且可以相互独立地进化。如果多个服务访问相同的数据，架构更新需要对所有服务进行耗时、协调的更新。 </p>
<p>To make matters worse, different microservices often use different kinds of databases. Modern applications store and process diverse kinds of data and a relational database is not always the best choice. For some use cases, a particular NoSQL database might have a more convenient data model and offer much better performance and scalability. For example, it makes sense for a service that stores and queries text to use a text search engine such as Elasticsearch. Similarly, a service that stores social graph data should probably use a graph database, such as Neo4j. Consequently, microservices‑based applications often use a mixture of SQL and NoSQL databases, the so‑called <a href="http://martinfowler.com/bliki/PolyglotPersistence.html" target="_blank" rel="noopener">polyglot persistence</a> approach.</p>
<p>更糟糕的是，不同的微服务经常使用不同类型的数据库。现代应用程序存储和处理各种数据和关系数据库并不总是最佳选择。对于某些用例，特定的NoSQL数据库可能具有更方便的数据模型，并提供更好的性能和可伸缩性。例如，存储和查询文本的服务使用文本搜索引擎(如ElasticSearch)是有意义的。类似地，存储社交图形数据的服务可能应该使用图形数据库，如ne4j。因此，基于微服务的应用程序通常使用SQL和NoSQL数据库的混合，即所谓的Polyglot持久化方法。 </p>
<p>A partitioned, polyglot‑persistent architecture for data storage has many benefits, including loosely coupled services and better performance and scalability. However, it does introduce some distributed data management challenges.</p>
<p>用于数据存储的分区的、多标记的持久性体系结构有许多好处，包括松散耦合的服务以及更好的性能和可伸缩性。然而，它确实带来了一些分布式数据管理方面的挑战。 </p>
<p>The first challenge is how to implement business transactions that maintain consistency across multiple services. To see why this is a problem, let’s take a look at an example of an online B2B store. The Customer Service maintains information about customers, including their credit lines. The Order Service manages orders and must verify that a new order doesn’t exceed the customer’s credit limit. In the monolithic version of this application, the Order Service can simply use an ACID transaction to check the available credit and create the order.</p>
<p>第一个挑战是如何实现跨多个服务保持一致性的业务事务。为了了解为什么这是一个问题，让我们来看看一个在线B2B商店的例子。客户服务维护有关客户的信息，包括他们的信用额度。订单服务管理订单，并必须验证新订单不超过客户的信用限额。在这个应用程序的单块版本中，订单服务可以简单地使用ACID事务来检查可用的信用并创建订单。 </p>
<p>In contrast, in a microservices architecture the ORDER and CUSTOMER tables are private to their respective services, as shown in the following diagram.</p>
<p>相反，在微服务体系结构中，Order表和Customer表对于各自的服务是私有的，如下图所示。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-separate-tables-e1449727641793.png" alt="Each service in a microservices architecture maintains a private database table"></p>
<p>The Order Service cannot access the CUSTOMER table directly. It can only use the API provided by the Customer Service. The Order Service could potentially use <a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="noopener">distributed transactions</a>, also known as two‑phase commit (2PC). However, 2PC is usually not a viable option in modern applications. The <a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener">CAP theorem</a> requires you to choose between availability and ACID‑style consistency, and availability is usually the better choice. Moreover, many modern technologies, such as most NoSQL databases, do not support 2PC. Maintaining data consistency across services and databases is essential, so we need another solution.</p>
<p>订单服务无法直接访问客户表。它只能使用客户服务提供的API。订单服务可能会使用分布式事务处理，也称为两相提交（2PC）。然而，在现代应用中，2PC通常不是可行的选择。CAP定理要求您在可用性和酸样式一致性之间进行选择，可用性通常是更好的选择。此外，许多现代技术（如大多数NOSQL数据库）不支持2PC。保持跨服务和数据库的数据一致性是至关重要的，因此我们需要另一个解决方案。 </p>
<p>The second challenge is how to implement queries that retrieve data from multiple services. For example, let’s imagine that the application needs to display a customer and his recent orders. If the Order Service provides an API for retrieving a customer’s orders then you can retrieve this data using an application‑side join. The application retrieves the customer from the Customer Service and the customer’s orders from the Order Service. Suppose, however, that the Order Service only supports the lookup of orders by their primary key (perhaps it uses a NoSQL database that only supports primary key‑based retrievals). In this situation, there is no obvious way to retrieve the needed data.</p>
<p>第二个挑战是如何实现从多个服务检索数据的查询。例如，假设应用程序需要显示客户和他最近的订单。如果订单服务提供了用于检索客户订单的API，那么您可以使用应用程序端连接来检索这些数据。应用程序从客户服务中检索客户，从订单服务检索客户的订单。但是，假设Order服务只支持通过主键查找订单(也许它使用的是只支持基于主键的检索的NoSQL数据库)。在这种情况下，没有明显的方法来检索所需的数据</p>
<h2 id="Event‑Driven-Architecture-事件驱动体系结构"><a href="#Event‑Driven-Architecture-事件驱动体系结构" class="headerlink" title="Event‑Driven Architecture 事件驱动体系结构"></a>Event‑Driven Architecture 事件驱动体系结构</h2><p>For many applications, the solution is to use an <a href="http://martinfowler.com/eaaDev/EventNarrative.html" target="_blank" rel="noopener">event‑driven architecture</a>. In this architecture, a microservice publishes an event when something notable happens, such as when it updates a business entity. Other microservices subscribe to those events. When a microservice receives an event it can update its own business entities, which might lead to more events being published.</p>
<p>对于许多应用程序，解决方案是使用事件驱动的体系结构。在此体系结构中，微服务在发生一些值得注意的事情时发布事件，例如更新业务实体时。其他微服务订阅了这些事件。当微服务接收到事件时，它可以更新自己的业务实体，这可能会导致更多事件被发布。 </p>
<p>You can use events to implement business transactions that span multiple services. A transaction consists of a series of steps. Each step consists of a microservice updating a business entity and publishing an event that triggers the next step. The following sequence of diagrams shows how you can use an event‑driven approach to checking for available credit when creating an order. The microservices exchange events via a Message Broker.</p>
<p>您可以使用事件来实现跨多个服务的业务事务。事务由一系列步骤组成。每个步骤都包含一个微服务，用于更新业务实体并发布触发下一步的事件。以下图表序列显示如何在创建订单时使用事件驱动方法检查可用信用。微服务通过消息代理交换事件。</p>
<ol>
<li><p>The Order Service creates an Order with status NEW and publishes an Order Created event.  Order服务创建状态为New的订单，并发布订单创建事件。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-1-e1449727610972.png" alt="In step 1 of a credit check in a microservices architecture, the Order Service publishes an &#39;Order Created&#39; event"></p>
</li>
<li><p>The Customer Service consumes the Order Created event, reserves credit for the order, and publishes a Credit Reserved event. 客户服务使用订单创建事件，为订单保留信用，并发布信用保留事件。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-2-e1449727579423.png" alt="In a microservices architecture, the second step in a credit check is for the Customer Service to generate a &#39;Credit Reserved&#39; event"></p>
</li>
<li><p>The Order Service consumes the Credit Reserved event, and changes the status of the order to OPEN. 订单服务使用信用保留事件，并将订单的状态更改为打开。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-3-e1449727548440.png" alt="In a microservices architecture, the third step in a credit check is for the Order Service to set the order status to &#39;Open&#39;"></p>
</li>
</ol>
<p>A more complex scenario could involve additional steps, such as reserving inventory at the same time the customer’s credit is checked.</p>
<p>更复杂的场景可能涉及其他步骤，例如在检查客户信用时保留库存。</p>
<p>Provided that (a) each service atomically updates the database and publishes an event – more on that later – and (b) the Message Broker guarantees that events are delivered at least once, then you can implement business transactions that span multiple services. It is important to note that these are not ACID transactions. They offer much weaker guarantees such as <a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="_blank" rel="noopener">eventual consistency</a>. This transaction model has been referred to as the <a href="http://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">BASE model</a>.</p>
<p>只要(A)每个服务原子地更新数据库并发布一个事件(稍后会有更多的消息)和(B)MessageBroker保证事件至少交付一次，那么您就可以实现跨多个服务的业务事务。必须指出的是，这些不是ACID交易。它们提供的担保要弱得多，比如最终的一致性。这个事务模型被称为基本模型。 </p>
<p>You can also use events to maintain materialized views that pre‑join data owned by multiple microservices. The service that maintains the view subscribes to the relevant events and updates the view. For example, the Customer Order View Updater Service that maintains a Customer Orders view subscribes to the events published by the Customer Service and Order Service.</p>
<p>您还可以使用事件来维护由多个微服务拥有的预联接数据的物化视图。维护视图的服务订阅相关事件并更新视图。例如，维护CustomerOrders视图的CustomerOrder视图更新服务订阅由客户服务和订单服务发布的事件。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-subscribe-e1449727516992.png" alt="In a microservices architecture, a service can subscribe to event notifications published by other services as triggers for action"></p>
<p>When the Customer Order View Updater Service receives a Customer or Order event, it updates the Customer Order View datastore. You could implement the Customer Order View using a document database such as MongoDB and store one document for each Customer. The Customer Order View Query Service handles requests for a customer and recent orders by querying the Customer Order View datastore.</p>
<p>当客户订单视图更新服务接收到客户或订单事件时，它将更新客户订单视图数据存储。您可以使用文档数据库(如MongoDB)实现CustomerOrder视图，并为每个客户存储一个文档。客户订单视图查询服务通过查询Customer Order视图数据存储来处理对客户和最近订单的请求。</p>
<p>An event‑driven architecture has several benefits and drawbacks. It enables the implementation of transactions that span multiple services and provide eventual consistency. Another benefit is that it also enables an application to maintain materialized views. One drawback is that the programming model is more complex than when using ACID transactions. Often you must implement compensating transactions to recover from application‑level failures; for example, you must cancel an order if the credit check fails. Also, applications must deal with inconsistent data. That is because changes made by in‑flight transactions are visible. The application can also see inconsistencies if it reads from a materialized view that is not yet updated. Another drawback is that subscribers must detect and ignore duplicate events.</p>
<p>事件驱动的体系结构有几个优点和缺点。它实现跨多个服务并提供最终一致性的事务。另一个优点是它还使应用程序能够维护实例化视图。一个缺点是编程模型比使用酸事务时更复杂。通常，您必须实施补偿事务处理才能从应用程序级故障中恢复；例如，如果信用检查失败，则必须取消订单。此外，应用程序必须处理不一致的数据。这是因为飞行中事务所做的更改是可见的。如果应用程序从尚未更新的实体化视图中读取，也可以看到不一致。另一个缺点是订户必须检测和忽略重复事件。</p>
<h2 id="Achieving-Atomicity-实现原子性"><a href="#Achieving-Atomicity-实现原子性" class="headerlink" title="Achieving Atomicity 实现原子性"></a>Achieving Atomicity 实现原子性</h2><p>In an event‑driven architecture there is also the problem of atomically updating the database and publishing an event. For example, the Order Service must insert a row into the ORDER table and publish an Order Created event. It is essential that these two operations are done atomically. If the service crashes after updating the database but before publishing the event, the system becomes inconsistent. The standard way to ensure atomicity is to use a distributed transaction involving the database and the Message Broker. However, for the reasons described above, such as the CAP theorem, this is exactly what we do not want to do.</p>
<p>在事件驱动的体系结构中，也存在着原子更新数据库和发布事件的问题。例如，Order服务必须向Order表中插入一行并发布创建的订单事件。这两个操作必须以原子方式完成。如果服务在更新数据库后但在发布事件之前崩溃，则系统将变得不一致。确保原子性的标准方法是使用涉及数据库和消息代理的分布式事务。然而，由于上述原因，如上限定理，这正是我们不想做的。 </p>
<h3 id="Publishing-Events-Using-Local-Transactions-使用本地事务发布事件"><a href="#Publishing-Events-Using-Local-Transactions-使用本地事务发布事件" class="headerlink" title="Publishing Events Using Local Transactions 使用本地事务发布事件"></a>Publishing Events Using Local Transactions 使用本地事务发布事件</h3><p>One way to achieve atomicity is for the application to publish events using a <a href="http://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">multi‑step process involving only local transactions</a>. The trick is to have an EVENT table, which functions as a message queue, in the database that stores the state of the business entities. The application begins a (local) database transaction, updates the state of the business entities, inserts an event into the EVENT table, and commits the transaction. A separate application thread or process queries the EVENT table, publishes the events to the Message Broker, and then uses a local transaction to mark the events as published. The following diagram shows the design.</p>
<p>实现原子性的一种方法是应用程序使用只涉及本地事务的多步骤进程发布事件。关键是在存储业务实体状态的数据库中具有一个作为消息队列的事件表。应用程序开始（本地）数据库事务，更新业务实体的状态，将事件插入到事件表中，并提交该事务。单独的应用程序线程或进程查询事件表，将事件发布到消息代理，然后使用本地事务将事件标记为已发布。下图显示了设计。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-local-transaction-e1449727484579.png" alt="In a microservices architecture, achieve atomicity by using only local transactions to publish events"></p>
<p>The Order Service inserts a row into the ORDER table and inserts an Order Created event into the EVENT table. The Event Publisher thread or process queries the EVENT table for unpublished events, publishes the events, and then updates the EVENT table to mark the events as published.</p>
<p>Order服务将一行插入Order表，并将Order创建的事件插入事件表。事件发布线程或进程查询未发布事件的事件表，发布事件，然后更新事件表，将事件标记为已发布的事件。</p>
<p>This approach has several benefits and drawbacks. One benefit is that it guarantees an event is published for each update without relying on 2PC. Also, the application publishes business‑level events, which eliminates the need to infer them. One drawback of this approach is that it is potentially error‑prone since the developer must remember to publish events. A limitation of this approach is that it is challenging to implement when using some NoSQL databases because of their limited transaction and query capabilities.</p>
<p>这种方法有几个优点和缺点。一个好处是，它可以保证为每个更新发布一个事件，而不依赖于2pc。此外，应用程序发布业务级别的事件，这消除了推断它们的需要。这种方法的一个缺点是它可能容易出错，因为开发人员必须记住发布事件。这种方法的一个限制是在使用某些NoSQL数据库时很难实现，因为它们的事务和查询功能有限。 </p>
<p>This approach eliminates the need for 2PC by having the application use local transactions to update state and publish events. Let’s now look at an approach that achieves atomicity by having the application simply update state.</p>
<p>这种方法通过让应用程序使用本地事务来更新状态和发布事件，从而消除了对2PC的需求。现在让我们来看看一种通过让应用程序简单地更新状态来实现原子性的方法。 </p>
<h3 id="Mining-a-Database-Transaction-Log-挖掘数据库事务日志"><a href="#Mining-a-Database-Transaction-Log-挖掘数据库事务日志" class="headerlink" title="Mining a Database Transaction Log 挖掘数据库事务日志"></a>Mining a Database Transaction Log 挖掘数据库事务日志</h3><p>Another way to achieve atomicity without 2PC is for the events to be published by a thread or process that mines the database’s transaction or commit log. The application updates the database, which results in changes being recorded in the database’s transaction log. The Transaction Log Miner thread or process reads the transaction log and publishes events to the Message Broker. The following diagram shows the design.</p>
<p>另一种在没有2PC的情况下实现原子性的方法是，事件由挖掘数据库事务或提交日志的线程或进程发布。应用程序更新数据库，从而在数据库的事务日志中记录更改。事务日志挖掘程序线程或进程读取事务日志并将事件发布到消息代理。下图显示了设计。</p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-transaction-log-e1449727434678.png" alt="In a microservices architecture, achieve atomicity by mining the transaction log for events"></p>
<p>A example of this approach is the open source <a href="https://github.com/linkedin/databus" target="_blank" rel="noopener">LinkedIn Databus</a> project. Databus mines the Oracle transaction log and publishes events corresponding to the changes. LinkedIn uses Databus to keep various derived data stores consistent with the system of record.</p>
<p>此方法的一个示例是开源LinkedInDatabus项目。数据库挖掘Oracle事务日志并发布与更改相对应的事件。LinkedIn使用数据库来保存与记录系统一致的各种衍生数据存储。</p>
<p>Another example is the <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html" target="_blank" rel="noopener">streams mechanism in AWS DynamoDB</a>, which is a managed NoSQL database. A DynamoDB stream contains the time‑ordered sequence of changes (create, update, and delete operations) made to the items in a DynamoDB table in the last 24 hours. An application can read those changes from the stream and, for example, publish them as events.</p>
<p>另一个例子是AWS DynamoDB中的Streams机制，它是一个托管的NoSQL数据库。DynamoDB流包含过去24小时内对DynamoDB表中的项进行的按时间顺序的更改序列(创建、更新和删除操作)。应用程序可以从流中读取这些更改，例如，将它们发布为事件。</p>
<p>Transaction log mining has various benefits and drawbacks. One benefit is that it guarantees that an event is published for each update without using 2PC. Transaction log mining can also simplify the application by separating event publishing from the application’s business logic. A major drawback is that the format of the transaction log is proprietary to each database and can even change between database versions. Also, it can be difficult to reverse engineer the high‑level business events from the low‑level updates recorded in the transaction log.</p>
<p>事务日志挖掘有不同的优缺点。一个好处是它可以保证在不使用2pc的情况下为每个更新发布一个事件。事务日志挖掘还可以通过将事件发布与应用程序的业务逻辑分离来简化应用程序。一个主要的缺点是事务日志的格式对每个数据库都是专有的，甚至可以在不同的数据库版本之间进行更改。此外，很难从事务日志中记录的低级更新中反向工程高级业务事件。 </p>
<p>Transaction log mining eliminates the need for 2PC by having the application do one thing: update the database. Let’s now look at a different approach that eliminates the updates and relies solely on events.</p>
<p>事务日志挖掘通过让应用程序执行以下操作消除了2pc的需求：更新数据库。现在，让我们看看消除更新并仅依赖于事件的其他方法。</p>
<h3 id="Using-Event-Sourcing-使用事件源"><a href="#Using-Event-Sourcing-使用事件源" class="headerlink" title="Using Event Sourcing 使用事件源"></a>Using Event Sourcing 使用事件源</h3><p><a href="https://github.com/cer/event-sourcing-examples/wiki/WhyEventSourcing" target="_blank" rel="noopener">Event sourcing</a> achieves atomicity without 2PC by using a radically different, event‑centric approach to persisting business entities. Rather than store the current state of an entity, the application stores a sequence of state‑changing events. The application reconstructs an entity’s current state by replaying the events. Whenever the state of a business entity changes, a new event is appended to the list of events. Since saving an event is a single operation, it is inherently atomic.</p>
<p>通过使用一种完全不同的、以事件为中心的方法来持久化业务实体，事件源可以在没有2PC的情况下实现原子性。应用程序不是存储实体的当前状态，而是存储一系列状态更改事件。应用程序通过重放事件重新构造实体的当前状态。每当业务实体的状态发生变化时，都会将新事件追加到事件列表中。因为保存一个事件是一个单一的操作，所以它本质上是原子的。 </p>
<p>To see how event sourcing works, consider the Order entity as an example. In a traditional approach, each order maps to a row in an ORDER table and to rows in, for example, an ORDER_LINE_ITEM table. But when using event sourcing, the Order Service stores an Order in the form of its state‑changing events: Created, Approved, Shipped, Cancelled. Each event contains sufficient data to reconstruct the Order’s state.</p>
<p>要查看事件源是如何工作的，请以Order实体为例。在传统方法中，每个订单映射到Order表中的一行和行，例如Order_line_Item表中的行。但是当使用事件源时，Order服务以其状态更改事件的形式存储订单：创建、批准、发送、取消。每个事件包含足够的数据来重建订单的状态。 </p>
<p><a href="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-event-sourcing-e1449711558668.png" target="_blank" rel="noopener"><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-event-sourcing-e1449711558668.png" alt="In a microservices architecture, achieve atomicity with event sourcing"></a></p>
<p>Events persist in an Event Store, which is a database of events. The store has an API for adding and retrieving an entity’s events. The Event Store also behaves like the Message Broker in the architectures we described previously. It provides an API that enables services to subscribe to events. The Event Store delivers all events to all interested subscribers. The Event Store is the backbone of an event‑driven microservices architecture.</p>
<p>事件持久化在事件存储区中，该存储库是一个事件数据库。存储有一个API，用于添加和检索实体的事件。事件存储也与我们前面描述的体系结构中的MessageBroker类似。它提供了一个API，使服务能够订阅事件。事件存储将所有事件传递给所有感兴趣的订阅者。事件存储是事件驱动的微服务体系结构的主干。 </p>
<p>Event sourcing has several benefits. It solves one of the key problems in implementing an event‑driven architecture and makes it possible to reliably publish events whenever state changes. As a result, it solves data consistency issues in a microservices architecture. Also, because it persists events rather than domain objects, it mostly avoids the <a href="https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch" target="_blank" rel="noopener">object‑relational impedance mismatch problem</a>. Event sourcing also provides a 100% reliable audit log of the changes made to a business entity, and makes it possible to implement temporal queries that determine the state of an entity at any point in time. Another major benefit of event sourcing is that your business logic consists of loosely coupled business entities that exchange events. This makes it a lot easier to migrate from a monolithic application to a microservices architecture.</p>
<p>事件来源补充有几个好处。它解决了实现事件驱动架构的关键问题之一，并可以在状态更改时可靠地发布事件。因此，它解决了微服务体系结构中的数据一致性问题。此外，因为它仍然存在事件而不是域对象，所以它主要避免了对象关系的阻抗失配问题。事件来源补充还提供对业务实体所做的更改的100%可靠的审核日志，并可以实现在任何时间点确定实体状态的时间查询。事件来源补充的另一个主要好处是业务逻辑由交换事件的松散耦合的业务实体组成。这使得从整体应用迁移到微服务体系结构更容易。 </p>
<p>Event sourcing also has some drawbacks. It is a different and unfamiliar style of programming and so there is a learning curve. The event store only directly supports the lookup of business entities by primary key. You must use <a href="https://github.com/cer/event-sourcing-examples/wiki" target="_blank" rel="noopener">Command Query Responsibility Segregation</a> (CQRS) to implement queries. As a result, applications must handle eventually consistent data.</p>
<p>事件源也有一些缺点。这是一种不同的和不熟悉的编程风格，因此有一个学习曲线。事件存储仅直接支持通过主键查找业务实体。必须使用命令查询责任隔离(Cqrs)来实现查询。因此，应用程序必须最终处理一致的数据。 </p>
<h2 id="Summary-概要"><a href="#Summary-概要" class="headerlink" title="Summary 概要"></a>Summary 概要</h2><p>In a microservices architecture, each microservice has its own private datastore. Different microservices might use different SQL and NoSQL databases. While this database architecture has significant benefits, it creates some distributed data management challenges. The first challenge is how to implement business transactions that maintain consistency across multiple services. The second challenge is how to implement queries that retrieve data from multiple services.</p>
<p>在微服务体系结构中，每个微服务都有自己的私有数据存储。不同的微服务可能使用不同的SQL和NoSQL数据库。虽然这种数据库架构有很大的好处，但它也带来了一些分布式数据管理方面的挑战。第一个挑战是如何实现跨多个服务保持一致性的业务事务。第二个挑战是如何实现从多个服务检索数据的查询。</p>
<p>For many applications, the solution is to use an event‑driven architecture. One challenge with implementing an event‑driven architecture is how to atomically update state and how to publish events. There are a few ways to accomplish this, including using the database as a message queue, transaction log mining, and event sourcing.</p>
<p>对于许多应用程序，解决方案是使用事件驱动的体系结构。实现事件驱动体系结构的一个挑战是如何原子地更新状态和如何发布事件。有几种方法可以实现这一点，包括将数据库用作消息队列、事务日志挖掘和事件源。 </p>
<p>In future blog posts, we’ll continue to dive into other aspects of microservices.</p>
<p>在未来的博客文章中，我们将继续深入到微观服务的其他方面。</p>
<p><em>Editor – This seven‑part series of articles is now complete:</em></p>
<p><em>编辑－此七部分系列文章现已完成：</em> </p>
<ol>
<li><a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="noopener">Introduction to Microservices</a> 微型服务简介 </li>
<li><a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/" target="_blank" rel="noopener">Building Microservices: Using an API Gateway</a> 构建微服务：使用API网关</li>
<li><a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/" target="_blank" rel="noopener">Building Microservices: Inter-Process Communication in a Microservices Architecture</a> 构建微服务：微服务体系结构中的进程间通信 </li>
<li><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" target="_blank" rel="noopener">Service Discovery in a Microservices Architecture</a> 微服务体系结构中的服务发现。 </li>
<li>Event-Driven Data Management for Microservices (this article) 事件驱动的微服务数据管理（本文） </li>
<li><a href="https://www.nginx.com/blog/deploying-microservices/" target="_blank" rel="noopener">Choosing a Microservices Deployment Strategy</a> 选择微服务部署策略 </li>
<li><a href="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/" target="_blank" rel="noopener">Refactoring a Monolith into Microservices</a> 将单核重构为微服务 </li>
</ol>
<p>You can also download the complete set of articles, plus information about implementing microservices using NGINX Plus, as an ebook – <a href="https://www.nginx.com/resources/library/designing-deploying-microservices/" target="_blank" rel="noopener">Microservices: From Design to Deployment</a>. And see our series on the <a href="https://www.nginx.com/blog/introducing-the-nginx-microservices-reference-architecture/" target="_blank" rel="noopener">Microservices Reference Architecture</a> and the <a href="https://www.nginx.com/solutions/microservices/" target="_blank" rel="noopener">Microservices Solutions page</a>.</p>
<p>您还可以下载完整的文章集，以及有关使用nginx+实现微服务的信息，作为电子书-microservices：从设计到部署。并在微服务参考体系结构和微服务解决方案页面上查看我们的系列文章。</p>
<p><em>Guest blogger Chris Richardson is the founder of the original CloudFoundry.com, an early Java PaaS (Platform as a Service) for Amazon EC2. He now consults with organizations to improve how they develop and deploy applications. He also blogs regularly about microservices at <a href="http://microservices.io" target="_blank" rel="noopener">http://microservices.io</a>.</em></p>
<p><em>嘉宾博客作者ChrisRichardson是最初的CloudFoundry.com的创始人，该网站是AmazonEC 2早期的java PaaS(平台即服务)。他现在与组织协商，以改进他们开发和部署应用程序的方式。他还定期在<a href="http://microservices.io.上发表关于微服务的博客。" target="_blank" rel="noopener">http://microservices.io.上发表关于微服务的博客。</a></em> </p>
<p>Microservices: From Design to Deployment </p>
<p>微服务：从设计到部署 </p>
<p>The complete guide to microservices development</p>
<p>微型服务开发完整指南<br><a href="https://www.nginx.com/resources/library/designing-deploying-microservices/" target="_blank" rel="noopener">DOWNLOAD NOW</a></p>
<p>现在下载</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(第11天more命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/20/一天一个Linux命令(第11天more命令)/">一天一个Linux命令(第10天more命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/20/一天一个Linux命令(第11天more命令)/" class="article-date">
	  <time datetime="2019-06-20T11:47:40.875Z" itemprop="datePublished">June 20, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MV命令"><a href="#MV命令" class="headerlink" title="MV命令"></a>MV命令</h2><ul>
<li><p>more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。</p>
<p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）可以用下列不同的方法对提示做出回答：</p>
<ul>
<li>按Space键：显示文本的下一屏内容。</li>
<li>按Enier键：只显示文本的下一行内容。</li>
<li>按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。</li>
<li>按H键：显示帮助屏，该屏上有相关的帮助信息。</li>
<li>按B键：显示上一屏内容。</li>
<li>按Q键：退出rnore命令。</li>
</ul>
</li>
</ul>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p><code>more(语法)(参数)</code></p>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&lt;数字&gt;：指定每屏显示的行数；</span><br><span class="line">-d：显示“[press space to continue,&apos;q&apos; to quit.]”和“[Press &apos;h&apos; for instructions]”；</span><br><span class="line">-c：不进行滚屏操作。每次刷新这个屏幕；</span><br><span class="line">-s：将多个空行压缩成一行显示；</span><br><span class="line">-u：禁止下划线；</span><br><span class="line">+&lt;数字&gt;：从指定数字的行开始显示。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件：指定分页显示内容的文件。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>显示文件file的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。</p>
<p><code>[work@aisp-communitycms-1-ptest aisp-community-cms]$ more -dc gc.log</code></p>
<p><img src="/2019/06/20/一天一个Linux命令(第11天more命令)/1561122816796.png" alt="1561122816796"></p>
<p>显示文件file的内容，每10行显示一次，而且在显示之前先清屏。</p>
<p><code>[work@aisp-communitycms-1-ptest aisp-community-cms]$ more -c -10 aisp-community-cms.log</code></p>
<p><img src="/2019/06/20/一天一个Linux命令(第11天more命令)/1561122853240.png" alt="1561122853240"></p>
<p>test</p>
<p><img src="/2019/06/20/一天一个Linux命令(第11天more命令)/1561122872815.png" alt="1561122872815"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/iTimeTraveler" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/06/28/Redis跳跃表/">Redis跳跃表</a></h6>
              <span>June 28, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/06/28/testfeng/">testfeng</a></h6>
              <span>June 28, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/06/27/一天一个Linux命令(whoami命令)/">一天一个Linux命令(whoami命令)</a></h6>
              <span>June 27, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/06/27/abc/">abc</a></h6>
              <span>June 27, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/06/26/一天一个Linux命令(watch命令)/">一天一个Linux命令(watch命令)</a></h6>
              <span>June 26, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/06/25/一天一个Linux命令(mkdir命令)/">一天一个Linux命令(mkdir命令)</a></h6>
              <span>June 25, 2019</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">20</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 Hexo All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
