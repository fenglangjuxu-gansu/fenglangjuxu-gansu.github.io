<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 3 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body>


  


<header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Hexo" rel="home"> Hexo </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-abc" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/27/abc/">abc</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/27/abc/" class="article-date">
	  <time datetime="2019-06-27T12:41:16.000Z" itemprop="datePublished">June 27, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2019/06/27/abc/1561639397783.png" alt="1561639397783"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(watch命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/26/一天一个Linux命令(watch命令)/">一天一个Linux命令(watch命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/26/一天一个Linux命令(watch命令)/" class="article-date">
	  <time datetime="2019-06-26T14:46:24.632Z" itemprop="datePublished">June 26, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="watch命令"><a href="#watch命令" class="headerlink" title="watch命令"></a>watch命令</h2><ul>
<li><strong>watch命令</strong>以周期性的方式执行给定的指令，指令输出以全屏方式显示。watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>   <code>watch(选项)(参数)</code></p>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n：指定指令执行的间隔时间（秒）；</span><br><span class="line">-d：高亮显示指令输出信息不同之处；</span><br><span class="line">-t：不显示标题。</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><p>指令：需要周期性执行的指令。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> uptime命令用来显示系统运行时间信息,   而watch uptime命令执行后会展示uptime信息：</p>
<p>当前时间   系统连续运行时间  当前用户连接数       系统平均负载（最近2分钟、9分钟、XX分钟）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[fenglangjuxu@localhost ~]$ </span><br><span class="line">[fenglangjuxu@localhost ~]$ </span><br><span class="line">[fenglangjuxu@localhost ~]$ watch uptime</span><br><span class="line">[fenglangjuxu@localhost ~]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Every 2.0s: uptime                                             Thu Jun 27 07:26:42 2019</span><br><span class="line"></span><br><span class="line"> 07:26:42 up 34 min,  2 users,  load average: 0.25, 0.19, 0.47</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(mkdir命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/25/一天一个Linux命令(mkdir命令)/">一天一个Linux命令(mkdir命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/25/一天一个Linux命令(mkdir命令)/" class="article-date">
	  <time datetime="2019-06-25T13:14:55.253Z" itemprop="datePublished">June 25, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><ul>
<li><p><strong>mkdir命令</strong>用来创建目录。该命令创建由<a href="http://man.linuxde.net/dirname" target="_blank" rel="noopener">dirname</a>命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 </p>
<p>注意：在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。</p>
<p>在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。。</p>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>   <code>mkdir (选项)(参数）</code></p>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><pre><code>-Z：设置安全上下文，当使用SELinux时有效；
-m&lt;目标属性&gt;或--mode&lt;目标属性&gt;建立目录的同时设置目录的权限；
-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
--version 显示版本信息。</code></pre><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><p>目录：指定要创建的目录列表，多个目录之间用空格隔开。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>在目录/var/local下建立子目录dongpengju，并且只有文件主有读、写和执行权限，其他人无权访问</p>
<pre><code>drwxr-xr-x.  4 root root   28 6月  22 04:14 target
drwxrwxrwt. 15 root root 4096 6月  26 05:21 tmp
drwxr-xr-x.  2 root root    6 4月  11 2018 yp
[root@localhost var]# cd loc
bash: cd: loc: 没有那个文件或目录
[root@localhost var]# cd loc
local/ lock/  
[root@localhost var]# cd loc
local/ lock/  
[root@localhost var]# cd local/
[root@localhost local]# ll
总用量 0
[root@localhost local]# pwd
/var/local
[root@localhost local]# mkdir -m 700 dongpengju
[root@localhost local]# ll
总用量 0
drwx------. 2 root root 6 6月  26 05:25 dongpengju
[root@localhost local]# </code></pre><p><img src="/2019/06/25/一天一个Linux命令(mkdir命令)/1561687781775.png" alt="1561687781775"></p>
<p>在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问</p>
<pre><code>[root@localhost local]# mkdir -p-m 750 fenglangjuxu/huoqubing
mkdir：无效选项 -- -
Try &apos;mkdir --help&apos; for more information.
[root@localhost local]# mkdir -p -m 750 fenglangjuxu/huoqubing
[root@localhost local]# ll
总用量 0
drwx------. 2 root root  6 6月  26 05:25 dongpengju
drwxr-xr-x. 3 root root 23 6月  26 05:30 fenglangjuxu
[root@localhost local]# </code></pre><p>​    </p>
<p><img src="/2019/06/25/一天一个Linux命令(mkdir命令)/1561469513882.png" alt="1561469513882"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(touch命令) " class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/24/一天一个Linux命令(touch命令) /">一天一个Linux命令(第6天touch命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/24/一天一个Linux命令(touch命令) /" class="article-date">
	  <time datetime="2019-06-24T14:37:32.076Z" itemprop="datePublished">June 24, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><ul>
<li><p><strong>touch命令</strong>有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。</p>
<p>当然了touch主要的功能是用来创建空文件，至少我常用来这么做。</p>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>   <code>touch(选项)(参数)</code></p>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><pre><code>-a：或--time=atime或--time=access或--time=use  只更改存取时间；
-c：或--no-create  不建立任何文件；
-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；
-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；
-m：或--time=mtime或--time=modify  只更该变动时间；
-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；
-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；
--help：在线帮助；
--version：显示版本信息。</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>  创建文件夹dongpengju，可以看到文件夹大小为0，是为空的：</p>
<pre><code>[fenglangjuxu@localhost usr]$ touch dongpengju
touch: 无法创建&quot;dongpengju&quot;: 权限不够
[fenglangjuxu@localhost usr]$ su root
密码：
[root@localhost usr]# pwd
/usr
[root@localhost usr]# touch dongpengju
[root@localhost usr]# ls
bin         etc    include  lib64    local  share  tmp
dongpengju  games  lib      libexec  sbin   src
[root@localhost usr]# ll
总用量 264
dr-xr-xr-x.   2 root root 49152 6月  22 04:37 bin
-rw-r--r--.   1 root root     0 6月  25 06:55 dongpengju
drwxr-xr-x.   2 root root     6 4月  11 2018 etc
drwxr-xr-x.   2 root root     6 4月  11 2018 games
drwxr-xr-x.   9 root root  4096 6月  22 04:34 include
dr-xr-xr-x.  42 root root  4096 6月  22 04:36 lib
dr-xr-xr-x. 142 root root 81920 6月  22 04:39 lib64
drwxr-xr-x.  49 root root 12288 6月  22 04:36 libexec
drwxr-xr-x.  12 root root   131 6月  22 04:07 local
dr-xr-xr-x.   2 root root 20480 6月  22 04:37 sbin
drwxr-xr-x. 235 root root  8192 6月  22 04:37 share
drwxr-xr-x.   4 root root    34 6月  22 04:07 src
lrwxrwxrwx.   1 root root    10 6月  22 04:07 tmp -&gt; ../var/tmp
[root@localhost usr]# </code></pre>
      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(第12天which命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/21/一天一个Linux命令(第12天which命令)/">一天一个Linux命令(第12天which命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/21/一天一个Linux命令(第12天which命令)/" class="article-date">
	  <time datetime="2019-06-21T13:28:04.785Z" itemprop="datePublished">June 21, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h1><ul>
<li><strong>which命令</strong>用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li>
</ul>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p><code>which(选项)(参数)</code></p>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;文件名长度&gt;：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；</span><br><span class="line">-p&lt;文件名长度&gt;：与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径；</span><br><span class="line">-w：指定输出时栏位的宽度；</span><br><span class="line">-V：显示版本信息。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>指令名：指令名列表。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>查找文件、显示命令路径：</p>
<p>zhiruo@luoyang MINGW64 /e/zhiruoblog<br>$</p>
<p>zhiruo@luoyang MINGW64 /e/zhiruoblog<br>$ which ls<br>/usr/bin/ls</p>
<p>zhiruo@luoyang MINGW64 /e/zhiruoblog<br>$ which chmod<br>/usr/bin/chmod</p>
<p>zhiruo@luoyang MINGW64 /e/zhiruoblog<br>$ which pwd<br>/usr/bin/pwd </p>
<p>如图：</p>
<p><img src="/2019/06/21/一天一个Linux命令(第12天which命令)/1561124360712.png" alt="1561124360712"></p>
<p>说明：which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Event-Driven Data Management for Microservices" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	<a href="/2019/06/21/Event-Driven Data Management for Microservices/" class="article-date">
	  <time datetime="2019-06-21T02:23:53.828Z" itemprop="datePublished">June 21, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Event-Driven-Data-Management-for-Microservices-用于微服务的事件驱动数据管理"><a href="#Event-Driven-Data-Management-for-Microservices-用于微服务的事件驱动数据管理" class="headerlink" title="Event-Driven Data Management for Microservices   用于微服务的事件驱动数据管理"></a>Event-Driven Data Management for Microservices   用于微服务的事件驱动数据管理</h1><p><em>Editor – This seven‑part series of articles is now complete:</em></p>
<p><em>编辑－此七部分系列文章现已完成：</em></p>
<ol>
<li><a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="noopener">Introduction to Microservices</a>  微服务构建微服务简介：</li>
<li><a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/" target="_blank" rel="noopener">Building Microservices: Using an API Gateway</a> 使用api网关构建微服务</li>
<li><a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/" target="_blank" rel="noopener">Building Microservices: Inter-Process Communication in a Microservices Architecture</a> 微服务体系结构中的进程间通信</li>
<li><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" target="_blank" rel="noopener">Service Discovery in a Microservices Architecture</a> 微服务体系结构中的服务发现</li>
<li>Event‑Driven Data Management for Microservices (this article) 事件驱动的微服务数据管理(本文)</li>
<li><a href="https://www.nginx.com/blog/deploying-microservices/" target="_blank" rel="noopener">Choosing a Microservices Deployment Strategy</a> 选择一种微服务部署策略</li>
<li><a href="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/" target="_blank" rel="noopener">Refactoring a Monolith into Microservices</a> 将单个微服务重构为微服务。</li>
</ol>
<p><em>You can also download the complete set of articles, plus information about implementing microservices using NGINX Plus, as an ebook – Microservices: From Design to Deployment. And see our series on the Microservices Reference Architecture and the Microservices Solutions page.</em></p>
<p><em>您还可以下载完整的文章集，以及有关使用nginx+实现微服务的信息，作为电子书-microservices：从设计到部署。并在微服务参考体系结构和微服务解决方案页面上查看我们的系列文章。</em> </p>
<p>This is the fifth article in a series about building applications with microservices. The <a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="noopener">first article</a> introduces the Microservices Architecture pattern and discusses the benefits and drawbacks of using microservices. The <a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway" target="_blank" rel="noopener">second</a> and <a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/" target="_blank" rel="noopener">third</a> articles in the series describe different aspects of communication within a microservices architecture. The <a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" target="_blank" rel="noopener">fourth article</a> explores the closely related problem of service discovery. In this article, we change gears and look at the distributed data management problems that arise in a microservices architecture.</p>
<p>这是关于使用微服务构建应用程序的系列文章的第五篇。第一篇文章介绍了微服务体系结构模式，讨论了使用微服务的优缺点。本系列的第二和第三篇文章描述了微服务体系结构中通信的不同方面。第四篇文章探讨了与服务发现密切相关的问题。在本文中，我们改变了方向，并研究了微服务体系结构中出现的分布式数据管理问题。</p>
<h2 id="Microservices-and-the-Problem-of-Distributed-Data-Management-微服务与分布式数据管理问题"><a href="#Microservices-and-the-Problem-of-Distributed-Data-Management-微服务与分布式数据管理问题" class="headerlink" title="Microservices and the Problem of Distributed Data Management 微服务与分布式数据管理问题"></a>Microservices and the Problem of Distributed Data Management 微服务与分布式数据管理问题</h2><p>A monolithic application typically has a single relational database. A key benefit of using a relational database is that your application can use <a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID transactions</a>, which provide some important guarantees:</p>
<p>单块应用程序通常有一个关系数据库。使用关系数据库的一个主要好处是应用程序可以使用ACID事务，这提供了一些重要的保证： </p>
<ul>
<li>Atomicity – Changes are made atomically 原子性-原子化改变 </li>
<li>Consistency – The state of the database is always consistent 一致性-数据库的状态始终一致 </li>
<li>Isolation – Even though transactions are executed concurrently it appears they are executed serially 隔离-即使事务是并发执行的，它们似乎都是串行执行的。 </li>
<li>Durability – Once a transaction has committed it is not undone 持久性-事务一旦提交，就不会撤消。 </li>
</ul>
<p>As a result, your application can simply begin a transaction, change (insert, update, and delete) multiple rows, and commit the transaction.</p>
<p>因此，您的应用程序可以简单地开始事务、更改（插入、更新和删除）多行，并提交事务</p>
<p>Another great benefit of using a relational database is that it provides SQL, which is a rich, declarative, and standardized query language. You can easily write a query that combines data from multiple tables. The RDBMS query planner then determines the most optimal way to execute the query. You don’t have to worry about low‑level details such as how to access the database. And, because all of your application’s data is in one database, it is easy to query.</p>
<p>使用关系数据库的另一个好处是它提供了SQL，它是一个丰富的、声明性的和标准化的查询语言。您可以轻松编写将数据与多个表组合的查询。RDBMS查询规划器然后确定执行查询的最佳方式。您不必担心低级详细信息，例如如何访问数据库。而且，由于所有应用程序的数据都在一个数据库中，因此很容易查询。</p>
<p>Unfortunately, data access becomes much more complex when we move to a microservices architecture. That is because the data owned by each microservice is <a href="http://microservices.io/patterns/data/database-per-service.html" target="_blank" rel="noopener">private to that microservice</a> and can only be accessed via its API. Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another. If multiple services access the same data, schema updates require time‑consuming, coordinated updates to all of the services.</p>
<p>不幸的是，当我们转向微服务体系结构时，数据访问变得更加复杂。这是因为每个微服务拥有的数据都是该微服务的私有数据，并且只能通过其API访问。封装数据可以确保微服务是松散耦合的，并且可以相互独立地进化。如果多个服务访问相同的数据，架构更新需要对所有服务进行耗时、协调的更新。 </p>
<p>To make matters worse, different microservices often use different kinds of databases. Modern applications store and process diverse kinds of data and a relational database is not always the best choice. For some use cases, a particular NoSQL database might have a more convenient data model and offer much better performance and scalability. For example, it makes sense for a service that stores and queries text to use a text search engine such as Elasticsearch. Similarly, a service that stores social graph data should probably use a graph database, such as Neo4j. Consequently, microservices‑based applications often use a mixture of SQL and NoSQL databases, the so‑called <a href="http://martinfowler.com/bliki/PolyglotPersistence.html" target="_blank" rel="noopener">polyglot persistence</a> approach.</p>
<p>更糟糕的是，不同的微服务经常使用不同类型的数据库。现代应用程序存储和处理各种数据和关系数据库并不总是最佳选择。对于某些用例，特定的NoSQL数据库可能具有更方便的数据模型，并提供更好的性能和可伸缩性。例如，存储和查询文本的服务使用文本搜索引擎(如ElasticSearch)是有意义的。类似地，存储社交图形数据的服务可能应该使用图形数据库，如ne4j。因此，基于微服务的应用程序通常使用SQL和NoSQL数据库的混合，即所谓的Polyglot持久化方法。 </p>
<p>A partitioned, polyglot‑persistent architecture for data storage has many benefits, including loosely coupled services and better performance and scalability. However, it does introduce some distributed data management challenges.</p>
<p>用于数据存储的分区的、多标记的持久性体系结构有许多好处，包括松散耦合的服务以及更好的性能和可伸缩性。然而，它确实带来了一些分布式数据管理方面的挑战。 </p>
<p>The first challenge is how to implement business transactions that maintain consistency across multiple services. To see why this is a problem, let’s take a look at an example of an online B2B store. The Customer Service maintains information about customers, including their credit lines. The Order Service manages orders and must verify that a new order doesn’t exceed the customer’s credit limit. In the monolithic version of this application, the Order Service can simply use an ACID transaction to check the available credit and create the order.</p>
<p>第一个挑战是如何实现跨多个服务保持一致性的业务事务。为了了解为什么这是一个问题，让我们来看看一个在线B2B商店的例子。客户服务维护有关客户的信息，包括他们的信用额度。订单服务管理订单，并必须验证新订单不超过客户的信用限额。在这个应用程序的单块版本中，订单服务可以简单地使用ACID事务来检查可用的信用并创建订单。 </p>
<p>In contrast, in a microservices architecture the ORDER and CUSTOMER tables are private to their respective services, as shown in the following diagram.</p>
<p>相反，在微服务体系结构中，Order表和Customer表对于各自的服务是私有的，如下图所示。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-separate-tables-e1449727641793.png" alt="Each service in a microservices architecture maintains a private database table"></p>
<p>The Order Service cannot access the CUSTOMER table directly. It can only use the API provided by the Customer Service. The Order Service could potentially use <a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="noopener">distributed transactions</a>, also known as two‑phase commit (2PC). However, 2PC is usually not a viable option in modern applications. The <a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener">CAP theorem</a> requires you to choose between availability and ACID‑style consistency, and availability is usually the better choice. Moreover, many modern technologies, such as most NoSQL databases, do not support 2PC. Maintaining data consistency across services and databases is essential, so we need another solution.</p>
<p>订单服务无法直接访问客户表。它只能使用客户服务提供的API。订单服务可能会使用分布式事务处理，也称为两相提交（2PC）。然而，在现代应用中，2PC通常不是可行的选择。CAP定理要求您在可用性和酸样式一致性之间进行选择，可用性通常是更好的选择。此外，许多现代技术（如大多数NOSQL数据库）不支持2PC。保持跨服务和数据库的数据一致性是至关重要的，因此我们需要另一个解决方案。 </p>
<p>The second challenge is how to implement queries that retrieve data from multiple services. For example, let’s imagine that the application needs to display a customer and his recent orders. If the Order Service provides an API for retrieving a customer’s orders then you can retrieve this data using an application‑side join. The application retrieves the customer from the Customer Service and the customer’s orders from the Order Service. Suppose, however, that the Order Service only supports the lookup of orders by their primary key (perhaps it uses a NoSQL database that only supports primary key‑based retrievals). In this situation, there is no obvious way to retrieve the needed data.</p>
<p>第二个挑战是如何实现从多个服务检索数据的查询。例如，假设应用程序需要显示客户和他最近的订单。如果订单服务提供了用于检索客户订单的API，那么您可以使用应用程序端连接来检索这些数据。应用程序从客户服务中检索客户，从订单服务检索客户的订单。但是，假设Order服务只支持通过主键查找订单(也许它使用的是只支持基于主键的检索的NoSQL数据库)。在这种情况下，没有明显的方法来检索所需的数据</p>
<h2 id="Event‑Driven-Architecture-事件驱动体系结构"><a href="#Event‑Driven-Architecture-事件驱动体系结构" class="headerlink" title="Event‑Driven Architecture 事件驱动体系结构"></a>Event‑Driven Architecture 事件驱动体系结构</h2><p>For many applications, the solution is to use an <a href="http://martinfowler.com/eaaDev/EventNarrative.html" target="_blank" rel="noopener">event‑driven architecture</a>. In this architecture, a microservice publishes an event when something notable happens, such as when it updates a business entity. Other microservices subscribe to those events. When a microservice receives an event it can update its own business entities, which might lead to more events being published.</p>
<p>对于许多应用程序，解决方案是使用事件驱动的体系结构。在此体系结构中，微服务在发生一些值得注意的事情时发布事件，例如更新业务实体时。其他微服务订阅了这些事件。当微服务接收到事件时，它可以更新自己的业务实体，这可能会导致更多事件被发布。 </p>
<p>You can use events to implement business transactions that span multiple services. A transaction consists of a series of steps. Each step consists of a microservice updating a business entity and publishing an event that triggers the next step. The following sequence of diagrams shows how you can use an event‑driven approach to checking for available credit when creating an order. The microservices exchange events via a Message Broker.</p>
<p>您可以使用事件来实现跨多个服务的业务事务。事务由一系列步骤组成。每个步骤都包含一个微服务，用于更新业务实体并发布触发下一步的事件。以下图表序列显示如何在创建订单时使用事件驱动方法检查可用信用。微服务通过消息代理交换事件。</p>
<ol>
<li><p>The Order Service creates an Order with status NEW and publishes an Order Created event.  Order服务创建状态为New的订单，并发布订单创建事件。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-1-e1449727610972.png" alt="In step 1 of a credit check in a microservices architecture, the Order Service publishes an &#39;Order Created&#39; event"></p>
</li>
<li><p>The Customer Service consumes the Order Created event, reserves credit for the order, and publishes a Credit Reserved event. 客户服务使用订单创建事件，为订单保留信用，并发布信用保留事件。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-2-e1449727579423.png" alt="In a microservices architecture, the second step in a credit check is for the Customer Service to generate a &#39;Credit Reserved&#39; event"></p>
</li>
<li><p>The Order Service consumes the Credit Reserved event, and changes the status of the order to OPEN. 订单服务使用信用保留事件，并将订单的状态更改为打开。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-3-e1449727548440.png" alt="In a microservices architecture, the third step in a credit check is for the Order Service to set the order status to &#39;Open&#39;"></p>
</li>
</ol>
<p>A more complex scenario could involve additional steps, such as reserving inventory at the same time the customer’s credit is checked.</p>
<p>更复杂的场景可能涉及其他步骤，例如在检查客户信用时保留库存。</p>
<p>Provided that (a) each service atomically updates the database and publishes an event – more on that later – and (b) the Message Broker guarantees that events are delivered at least once, then you can implement business transactions that span multiple services. It is important to note that these are not ACID transactions. They offer much weaker guarantees such as <a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="_blank" rel="noopener">eventual consistency</a>. This transaction model has been referred to as the <a href="http://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">BASE model</a>.</p>
<p>只要(A)每个服务原子地更新数据库并发布一个事件(稍后会有更多的消息)和(B)MessageBroker保证事件至少交付一次，那么您就可以实现跨多个服务的业务事务。必须指出的是，这些不是ACID交易。它们提供的担保要弱得多，比如最终的一致性。这个事务模型被称为基本模型。 </p>
<p>You can also use events to maintain materialized views that pre‑join data owned by multiple microservices. The service that maintains the view subscribes to the relevant events and updates the view. For example, the Customer Order View Updater Service that maintains a Customer Orders view subscribes to the events published by the Customer Service and Order Service.</p>
<p>您还可以使用事件来维护由多个微服务拥有的预联接数据的物化视图。维护视图的服务订阅相关事件并更新视图。例如，维护CustomerOrders视图的CustomerOrder视图更新服务订阅由客户服务和订单服务发布的事件。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-subscribe-e1449727516992.png" alt="In a microservices architecture, a service can subscribe to event notifications published by other services as triggers for action"></p>
<p>When the Customer Order View Updater Service receives a Customer or Order event, it updates the Customer Order View datastore. You could implement the Customer Order View using a document database such as MongoDB and store one document for each Customer. The Customer Order View Query Service handles requests for a customer and recent orders by querying the Customer Order View datastore.</p>
<p>当客户订单视图更新服务接收到客户或订单事件时，它将更新客户订单视图数据存储。您可以使用文档数据库(如MongoDB)实现CustomerOrder视图，并为每个客户存储一个文档。客户订单视图查询服务通过查询Customer Order视图数据存储来处理对客户和最近订单的请求。</p>
<p>An event‑driven architecture has several benefits and drawbacks. It enables the implementation of transactions that span multiple services and provide eventual consistency. Another benefit is that it also enables an application to maintain materialized views. One drawback is that the programming model is more complex than when using ACID transactions. Often you must implement compensating transactions to recover from application‑level failures; for example, you must cancel an order if the credit check fails. Also, applications must deal with inconsistent data. That is because changes made by in‑flight transactions are visible. The application can also see inconsistencies if it reads from a materialized view that is not yet updated. Another drawback is that subscribers must detect and ignore duplicate events.</p>
<p>事件驱动的体系结构有几个优点和缺点。它实现跨多个服务并提供最终一致性的事务。另一个优点是它还使应用程序能够维护实例化视图。一个缺点是编程模型比使用酸事务时更复杂。通常，您必须实施补偿事务处理才能从应用程序级故障中恢复；例如，如果信用检查失败，则必须取消订单。此外，应用程序必须处理不一致的数据。这是因为飞行中事务所做的更改是可见的。如果应用程序从尚未更新的实体化视图中读取，也可以看到不一致。另一个缺点是订户必须检测和忽略重复事件。</p>
<h2 id="Achieving-Atomicity-实现原子性"><a href="#Achieving-Atomicity-实现原子性" class="headerlink" title="Achieving Atomicity 实现原子性"></a>Achieving Atomicity 实现原子性</h2><p>In an event‑driven architecture there is also the problem of atomically updating the database and publishing an event. For example, the Order Service must insert a row into the ORDER table and publish an Order Created event. It is essential that these two operations are done atomically. If the service crashes after updating the database but before publishing the event, the system becomes inconsistent. The standard way to ensure atomicity is to use a distributed transaction involving the database and the Message Broker. However, for the reasons described above, such as the CAP theorem, this is exactly what we do not want to do.</p>
<p>在事件驱动的体系结构中，也存在着原子更新数据库和发布事件的问题。例如，Order服务必须向Order表中插入一行并发布创建的订单事件。这两个操作必须以原子方式完成。如果服务在更新数据库后但在发布事件之前崩溃，则系统将变得不一致。确保原子性的标准方法是使用涉及数据库和消息代理的分布式事务。然而，由于上述原因，如上限定理，这正是我们不想做的。 </p>
<h3 id="Publishing-Events-Using-Local-Transactions-使用本地事务发布事件"><a href="#Publishing-Events-Using-Local-Transactions-使用本地事务发布事件" class="headerlink" title="Publishing Events Using Local Transactions 使用本地事务发布事件"></a>Publishing Events Using Local Transactions 使用本地事务发布事件</h3><p>One way to achieve atomicity is for the application to publish events using a <a href="http://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">multi‑step process involving only local transactions</a>. The trick is to have an EVENT table, which functions as a message queue, in the database that stores the state of the business entities. The application begins a (local) database transaction, updates the state of the business entities, inserts an event into the EVENT table, and commits the transaction. A separate application thread or process queries the EVENT table, publishes the events to the Message Broker, and then uses a local transaction to mark the events as published. The following diagram shows the design.</p>
<p>实现原子性的一种方法是应用程序使用只涉及本地事务的多步骤进程发布事件。关键是在存储业务实体状态的数据库中具有一个作为消息队列的事件表。应用程序开始（本地）数据库事务，更新业务实体的状态，将事件插入到事件表中，并提交该事务。单独的应用程序线程或进程查询事件表，将事件发布到消息代理，然后使用本地事务将事件标记为已发布。下图显示了设计。 </p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-local-transaction-e1449727484579.png" alt="In a microservices architecture, achieve atomicity by using only local transactions to publish events"></p>
<p>The Order Service inserts a row into the ORDER table and inserts an Order Created event into the EVENT table. The Event Publisher thread or process queries the EVENT table for unpublished events, publishes the events, and then updates the EVENT table to mark the events as published.</p>
<p>Order服务将一行插入Order表，并将Order创建的事件插入事件表。事件发布线程或进程查询未发布事件的事件表，发布事件，然后更新事件表，将事件标记为已发布的事件。</p>
<p>This approach has several benefits and drawbacks. One benefit is that it guarantees an event is published for each update without relying on 2PC. Also, the application publishes business‑level events, which eliminates the need to infer them. One drawback of this approach is that it is potentially error‑prone since the developer must remember to publish events. A limitation of this approach is that it is challenging to implement when using some NoSQL databases because of their limited transaction and query capabilities.</p>
<p>这种方法有几个优点和缺点。一个好处是，它可以保证为每个更新发布一个事件，而不依赖于2pc。此外，应用程序发布业务级别的事件，这消除了推断它们的需要。这种方法的一个缺点是它可能容易出错，因为开发人员必须记住发布事件。这种方法的一个限制是在使用某些NoSQL数据库时很难实现，因为它们的事务和查询功能有限。 </p>
<p>This approach eliminates the need for 2PC by having the application use local transactions to update state and publish events. Let’s now look at an approach that achieves atomicity by having the application simply update state.</p>
<p>这种方法通过让应用程序使用本地事务来更新状态和发布事件，从而消除了对2PC的需求。现在让我们来看看一种通过让应用程序简单地更新状态来实现原子性的方法。 </p>
<h3 id="Mining-a-Database-Transaction-Log-挖掘数据库事务日志"><a href="#Mining-a-Database-Transaction-Log-挖掘数据库事务日志" class="headerlink" title="Mining a Database Transaction Log 挖掘数据库事务日志"></a>Mining a Database Transaction Log 挖掘数据库事务日志</h3><p>Another way to achieve atomicity without 2PC is for the events to be published by a thread or process that mines the database’s transaction or commit log. The application updates the database, which results in changes being recorded in the database’s transaction log. The Transaction Log Miner thread or process reads the transaction log and publishes events to the Message Broker. The following diagram shows the design.</p>
<p>另一种在没有2PC的情况下实现原子性的方法是，事件由挖掘数据库事务或提交日志的线程或进程发布。应用程序更新数据库，从而在数据库的事务日志中记录更改。事务日志挖掘程序线程或进程读取事务日志并将事件发布到消息代理。下图显示了设计。</p>
<p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-transaction-log-e1449727434678.png" alt="In a microservices architecture, achieve atomicity by mining the transaction log for events"></p>
<p>A example of this approach is the open source <a href="https://github.com/linkedin/databus" target="_blank" rel="noopener">LinkedIn Databus</a> project. Databus mines the Oracle transaction log and publishes events corresponding to the changes. LinkedIn uses Databus to keep various derived data stores consistent with the system of record.</p>
<p>此方法的一个示例是开源LinkedInDatabus项目。数据库挖掘Oracle事务日志并发布与更改相对应的事件。LinkedIn使用数据库来保存与记录系统一致的各种衍生数据存储。</p>
<p>Another example is the <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html" target="_blank" rel="noopener">streams mechanism in AWS DynamoDB</a>, which is a managed NoSQL database. A DynamoDB stream contains the time‑ordered sequence of changes (create, update, and delete operations) made to the items in a DynamoDB table in the last 24 hours. An application can read those changes from the stream and, for example, publish them as events.</p>
<p>另一个例子是AWS DynamoDB中的Streams机制，它是一个托管的NoSQL数据库。DynamoDB流包含过去24小时内对DynamoDB表中的项进行的按时间顺序的更改序列(创建、更新和删除操作)。应用程序可以从流中读取这些更改，例如，将它们发布为事件。</p>
<p>Transaction log mining has various benefits and drawbacks. One benefit is that it guarantees that an event is published for each update without using 2PC. Transaction log mining can also simplify the application by separating event publishing from the application’s business logic. A major drawback is that the format of the transaction log is proprietary to each database and can even change between database versions. Also, it can be difficult to reverse engineer the high‑level business events from the low‑level updates recorded in the transaction log.</p>
<p>事务日志挖掘有不同的优缺点。一个好处是它可以保证在不使用2pc的情况下为每个更新发布一个事件。事务日志挖掘还可以通过将事件发布与应用程序的业务逻辑分离来简化应用程序。一个主要的缺点是事务日志的格式对每个数据库都是专有的，甚至可以在不同的数据库版本之间进行更改。此外，很难从事务日志中记录的低级更新中反向工程高级业务事件。 </p>
<p>Transaction log mining eliminates the need for 2PC by having the application do one thing: update the database. Let’s now look at a different approach that eliminates the updates and relies solely on events.</p>
<p>事务日志挖掘通过让应用程序执行以下操作消除了2pc的需求：更新数据库。现在，让我们看看消除更新并仅依赖于事件的其他方法。</p>
<h3 id="Using-Event-Sourcing-使用事件源"><a href="#Using-Event-Sourcing-使用事件源" class="headerlink" title="Using Event Sourcing 使用事件源"></a>Using Event Sourcing 使用事件源</h3><p><a href="https://github.com/cer/event-sourcing-examples/wiki/WhyEventSourcing" target="_blank" rel="noopener">Event sourcing</a> achieves atomicity without 2PC by using a radically different, event‑centric approach to persisting business entities. Rather than store the current state of an entity, the application stores a sequence of state‑changing events. The application reconstructs an entity’s current state by replaying the events. Whenever the state of a business entity changes, a new event is appended to the list of events. Since saving an event is a single operation, it is inherently atomic.</p>
<p>通过使用一种完全不同的、以事件为中心的方法来持久化业务实体，事件源可以在没有2PC的情况下实现原子性。应用程序不是存储实体的当前状态，而是存储一系列状态更改事件。应用程序通过重放事件重新构造实体的当前状态。每当业务实体的状态发生变化时，都会将新事件追加到事件列表中。因为保存一个事件是一个单一的操作，所以它本质上是原子的。 </p>
<p>To see how event sourcing works, consider the Order entity as an example. In a traditional approach, each order maps to a row in an ORDER table and to rows in, for example, an ORDER_LINE_ITEM table. But when using event sourcing, the Order Service stores an Order in the form of its state‑changing events: Created, Approved, Shipped, Cancelled. Each event contains sufficient data to reconstruct the Order’s state.</p>
<p>要查看事件源是如何工作的，请以Order实体为例。在传统方法中，每个订单映射到Order表中的一行和行，例如Order_line_Item表中的行。但是当使用事件源时，Order服务以其状态更改事件的形式存储订单：创建、批准、发送、取消。每个事件包含足够的数据来重建订单的状态。 </p>
<p><a href="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-event-sourcing-e1449711558668.png" target="_blank" rel="noopener"><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-event-sourcing-e1449711558668.png" alt="In a microservices architecture, achieve atomicity with event sourcing"></a></p>
<p>Events persist in an Event Store, which is a database of events. The store has an API for adding and retrieving an entity’s events. The Event Store also behaves like the Message Broker in the architectures we described previously. It provides an API that enables services to subscribe to events. The Event Store delivers all events to all interested subscribers. The Event Store is the backbone of an event‑driven microservices architecture.</p>
<p>事件持久化在事件存储区中，该存储库是一个事件数据库。存储有一个API，用于添加和检索实体的事件。事件存储也与我们前面描述的体系结构中的MessageBroker类似。它提供了一个API，使服务能够订阅事件。事件存储将所有事件传递给所有感兴趣的订阅者。事件存储是事件驱动的微服务体系结构的主干。 </p>
<p>Event sourcing has several benefits. It solves one of the key problems in implementing an event‑driven architecture and makes it possible to reliably publish events whenever state changes. As a result, it solves data consistency issues in a microservices architecture. Also, because it persists events rather than domain objects, it mostly avoids the <a href="https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch" target="_blank" rel="noopener">object‑relational impedance mismatch problem</a>. Event sourcing also provides a 100% reliable audit log of the changes made to a business entity, and makes it possible to implement temporal queries that determine the state of an entity at any point in time. Another major benefit of event sourcing is that your business logic consists of loosely coupled business entities that exchange events. This makes it a lot easier to migrate from a monolithic application to a microservices architecture.</p>
<p>事件来源补充有几个好处。它解决了实现事件驱动架构的关键问题之一，并可以在状态更改时可靠地发布事件。因此，它解决了微服务体系结构中的数据一致性问题。此外，因为它仍然存在事件而不是域对象，所以它主要避免了对象关系的阻抗失配问题。事件来源补充还提供对业务实体所做的更改的100%可靠的审核日志，并可以实现在任何时间点确定实体状态的时间查询。事件来源补充的另一个主要好处是业务逻辑由交换事件的松散耦合的业务实体组成。这使得从整体应用迁移到微服务体系结构更容易。 </p>
<p>Event sourcing also has some drawbacks. It is a different and unfamiliar style of programming and so there is a learning curve. The event store only directly supports the lookup of business entities by primary key. You must use <a href="https://github.com/cer/event-sourcing-examples/wiki" target="_blank" rel="noopener">Command Query Responsibility Segregation</a> (CQRS) to implement queries. As a result, applications must handle eventually consistent data.</p>
<p>事件源也有一些缺点。这是一种不同的和不熟悉的编程风格，因此有一个学习曲线。事件存储仅直接支持通过主键查找业务实体。必须使用命令查询责任隔离(Cqrs)来实现查询。因此，应用程序必须最终处理一致的数据。 </p>
<h2 id="Summary-概要"><a href="#Summary-概要" class="headerlink" title="Summary 概要"></a>Summary 概要</h2><p>In a microservices architecture, each microservice has its own private datastore. Different microservices might use different SQL and NoSQL databases. While this database architecture has significant benefits, it creates some distributed data management challenges. The first challenge is how to implement business transactions that maintain consistency across multiple services. The second challenge is how to implement queries that retrieve data from multiple services.</p>
<p>在微服务体系结构中，每个微服务都有自己的私有数据存储。不同的微服务可能使用不同的SQL和NoSQL数据库。虽然这种数据库架构有很大的好处，但它也带来了一些分布式数据管理方面的挑战。第一个挑战是如何实现跨多个服务保持一致性的业务事务。第二个挑战是如何实现从多个服务检索数据的查询。</p>
<p>For many applications, the solution is to use an event‑driven architecture. One challenge with implementing an event‑driven architecture is how to atomically update state and how to publish events. There are a few ways to accomplish this, including using the database as a message queue, transaction log mining, and event sourcing.</p>
<p>对于许多应用程序，解决方案是使用事件驱动的体系结构。实现事件驱动体系结构的一个挑战是如何原子地更新状态和如何发布事件。有几种方法可以实现这一点，包括将数据库用作消息队列、事务日志挖掘和事件源。 </p>
<p>In future blog posts, we’ll continue to dive into other aspects of microservices.</p>
<p>在未来的博客文章中，我们将继续深入到微观服务的其他方面。</p>
<p><em>Editor – This seven‑part series of articles is now complete:</em></p>
<p><em>编辑－此七部分系列文章现已完成：</em> </p>
<ol>
<li><a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="noopener">Introduction to Microservices</a> 微型服务简介 </li>
<li><a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/" target="_blank" rel="noopener">Building Microservices: Using an API Gateway</a> 构建微服务：使用API网关</li>
<li><a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/" target="_blank" rel="noopener">Building Microservices: Inter-Process Communication in a Microservices Architecture</a> 构建微服务：微服务体系结构中的进程间通信 </li>
<li><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" target="_blank" rel="noopener">Service Discovery in a Microservices Architecture</a> 微服务体系结构中的服务发现。 </li>
<li>Event-Driven Data Management for Microservices (this article) 事件驱动的微服务数据管理（本文） </li>
<li><a href="https://www.nginx.com/blog/deploying-microservices/" target="_blank" rel="noopener">Choosing a Microservices Deployment Strategy</a> 选择微服务部署策略 </li>
<li><a href="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/" target="_blank" rel="noopener">Refactoring a Monolith into Microservices</a> 将单核重构为微服务 </li>
</ol>
<p>You can also download the complete set of articles, plus information about implementing microservices using NGINX Plus, as an ebook – <a href="https://www.nginx.com/resources/library/designing-deploying-microservices/" target="_blank" rel="noopener">Microservices: From Design to Deployment</a>. And see our series on the <a href="https://www.nginx.com/blog/introducing-the-nginx-microservices-reference-architecture/" target="_blank" rel="noopener">Microservices Reference Architecture</a> and the <a href="https://www.nginx.com/solutions/microservices/" target="_blank" rel="noopener">Microservices Solutions page</a>.</p>
<p>您还可以下载完整的文章集，以及有关使用nginx+实现微服务的信息，作为电子书-microservices：从设计到部署。并在微服务参考体系结构和微服务解决方案页面上查看我们的系列文章。</p>
<p><em>Guest blogger Chris Richardson is the founder of the original CloudFoundry.com, an early Java PaaS (Platform as a Service) for Amazon EC2. He now consults with organizations to improve how they develop and deploy applications. He also blogs regularly about microservices at <a href="http://microservices.io" target="_blank" rel="noopener">http://microservices.io</a>.</em></p>
<p><em>嘉宾博客作者ChrisRichardson是最初的CloudFoundry.com的创始人，该网站是AmazonEC 2早期的java PaaS(平台即服务)。他现在与组织协商，以改进他们开发和部署应用程序的方式。他还定期在<a href="http://microservices.io.上发表关于微服务的博客。" target="_blank" rel="noopener">http://microservices.io.上发表关于微服务的博客。</a></em> </p>
<p>Microservices: From Design to Deployment </p>
<p>微服务：从设计到部署 </p>
<p>The complete guide to microservices development</p>
<p>微型服务开发完整指南<br><a href="https://www.nginx.com/resources/library/designing-deploying-microservices/" target="_blank" rel="noopener">DOWNLOAD NOW</a></p>
<p>现在下载</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(第11天more命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/20/一天一个Linux命令(第11天more命令)/">一天一个Linux命令(第10天more命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/20/一天一个Linux命令(第11天more命令)/" class="article-date">
	  <time datetime="2019-06-20T11:47:40.875Z" itemprop="datePublished">June 20, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MV命令"><a href="#MV命令" class="headerlink" title="MV命令"></a>MV命令</h2><ul>
<li><p>more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。</p>
<p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）可以用下列不同的方法对提示做出回答：</p>
<ul>
<li>按Space键：显示文本的下一屏内容。</li>
<li>按Enier键：只显示文本的下一行内容。</li>
<li>按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。</li>
<li>按H键：显示帮助屏，该屏上有相关的帮助信息。</li>
<li>按B键：显示上一屏内容。</li>
<li>按Q键：退出rnore命令。</li>
</ul>
</li>
</ul>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p><code>more(语法)(参数)</code></p>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&lt;数字&gt;：指定每屏显示的行数；</span><br><span class="line">-d：显示“[press space to continue,&apos;q&apos; to quit.]”和“[Press &apos;h&apos; for instructions]”；</span><br><span class="line">-c：不进行滚屏操作。每次刷新这个屏幕；</span><br><span class="line">-s：将多个空行压缩成一行显示；</span><br><span class="line">-u：禁止下划线；</span><br><span class="line">+&lt;数字&gt;：从指定数字的行开始显示。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件：指定分页显示内容的文件。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>显示文件file的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。</p>
<p><code>[work@aisp-communitycms-1-ptest aisp-community-cms]$ more -dc gc.log</code></p>
<p><img src="/2019/06/20/一天一个Linux命令(第11天more命令)/1561122816796.png" alt="1561122816796"></p>
<p>显示文件file的内容，每10行显示一次，而且在显示之前先清屏。</p>
<p><code>[work@aisp-communitycms-1-ptest aisp-community-cms]$ more -c -10 aisp-community-cms.log</code></p>
<p><img src="/2019/06/20/一天一个Linux命令(第11天more命令)/1561122853240.png" alt="1561122853240"></p>
<p>test</p>
<p><img src="/2019/06/20/一天一个Linux命令(第11天more命令)/1561122872815.png" alt="1561122872815"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Redis简单动态字符串" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/20/Redis简单动态字符串/">Redis简单动态字符串（ simple dynamic string， SDS）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/20/Redis简单动态字符串/" class="article-date">
	  <time datetime="2019-06-20T01:23:35.394Z" itemprop="datePublished">June 20, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、简单动态字符串-SDS"><a href="#1、简单动态字符串-SDS" class="headerlink" title="1、简单动态字符串(SDS)"></a>1、简单动态字符串(SDS)</h2><ul>
<li>Redis没有使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串的抽象类型，并将SDS用作Redis的默认字符串表示。</li>
</ul>
<pre><code>在Redis里面，C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方，比如打印日志。


当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。

举个例子，如果客户端执行命令：</code></pre><p>​     
​<br>        redis&gt; SET msg “hello world”<br>        OK<br> 那么Redis将在数据中创建一个新的键值对，其中：</p>
<pre><code>* 键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串 “msg” 的SDS。
* 键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS。

又比如， 如果客户端执行命令： 

    redis&gt; RPUSH fruits &quot;apple&quot; &quot;bannan&quot; &quot;cherry&quot;
    (integer) 3
那么Redis将在数据库中创建一个新的键值对，其中：</code></pre><ul>
<li><p>键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串“fruits”的SDS。</p>
</li>
<li><p>键值对的值也是一个字符串对象，列表对象包含了三个字符串对象，这三个字符串对象分别有三个SDS实现，第一个SDS保存着字符串apple， 第二个SDS保存着bannan，第三个SDS保存着cherry。</p>
<p>除了用来保存数据库中的字符串值之外，SDS还被用作缓存区（buffer）</p>
</li>
</ul>
<h6 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h6><p>​         C语言给字符串开辟一个存储空间，如果对此存储空间的使用超过开辟的空间，会导致内存溢出。例如使用字符串拼接等方式时，就很容易出现此问题。而如果每次拼接之前都要计算每个字符串的长度，时间上又要耗费很久。</p>
<p>​         redis的SDS中内置一个sdscat函数，也是用于字符串的拼接。但是在执行操作之前，其会先检查空间是否足够，通过比较当前字符串的free与即将拼接字符串的len的大小，就知道是否可以拼接。如果free的值不够，会再申请内存空间，避免溢出。</p>
<h6 id="修改字符串时的内存重分配"><a href="#修改字符串时的内存重分配" class="headerlink" title="修改字符串时的内存重分配"></a>修改字符串时的内存重分配</h6><p>​         C语言的字符串长度和底层数组之间存在关联，因此字符串长度增加时需要再分配存储空间，避免溢出；字符串长度减少时，需要释放存储空间，避免内存泄漏。</p>
<p> 由于redis中，字符串频繁修改是很经常发生的事情，redis的一个应用场景就是变量频繁修改的场景。为了避免C语言的不断重分配空间，redis进行了改进。</p>
<p>​         redis的sds，主要是通过free字段，来进行判断。通过未使用空间大小，实现了空间预分配和惰性空间释放。</p>
<p>​         1）空间预分配</p>
<p> 空间预分配用于优化字符串的增长操作，实现方式为：当需要增长字符串时，sds不仅会分配足够的空间用于增长，还会预分配未使用空间。</p>
<p>分配的规则是，如果增长字符串后，新的字符串比1MB小，则额外申请字符串当前所占空间的大小作为free值；如果增长后，字符串长度超过1MB，则额外申请1MB大小。</p>
<p>例如，字符串增长后，大小是50kb，则额外申请50kb作为未使用空间。如果字符串增长后的大小是20mb，则额外申请1mb作为未使用空间。以上两种情况都为将\0计算在内，因此，实际上还会需要1字节作为\0存放的空间。</p>
<p>上述机制，避免了redis字符串增长情况下频繁申请空间的情况。每次字符串增长之前，sds会先检查空间是否足够，如果足够则直接使用预分配的空间，否则按照上述机制申请使用空间。该机制，使得字符串增长n次，需要申请空间的次数，从必定为n次的情况，降为最多n次的情况。</p>
<p>2）懒惰空间释放</p>
<p>懒惰空间释放用于优化sds字符串缩短的操作，实现方式为：当需要缩短sds的长度时，并不立即释放空间，而是使用free来保存剩余可用长度，并等待将来使用。当有剩余空间，而有有增长字符串操作时，则又会调用空间预分配机制。</p>
<p>当redis内存空间不足时，会自动释放sds中未使用的空间，因此也不需要担心内存泄漏问题。</p>
<h6 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h6><p>​         C语言的字符必须符合某种编码，例如ascii，且字符串除了末尾之外，不能有空格，否则会被当作是另一个字符串。这些限制使得c语言的字符串只能保存不含空格的文本，不能保存图片、视频等二进制数据，也不能保存包含空格的文本。</p>
<p> 而保存图片、大段文本等内容，也是redis的常用场景。因此，redis也对此进行优化。因此，sds是二进制安全的，写入的是什么内容，返回的也是什么内容，并没有限制。</p>
<p>​         redis的sds，用buf保存字符串，保存的就是一系列的二进制数据。因为，sds考虑字符串长度，是通过len属性，而不是通过\0来判断。</p>
<h6 id="C语言字符串函数"><a href="#C语言字符串函数" class="headerlink" title="C语言字符串函数"></a>C语言字符串函数</h6><p>​         redis兼容c语言对于字符串末尾采用\0进行处理，这样使得其可以复用部分c语言字符串函数的代码，实现代码的精简性。</p>
<h6 id="总结——C语言字符串和SDS字符串比较"><a href="#总结——C语言字符串和SDS字符串比较" class="headerlink" title="总结——C语言字符串和SDS字符串比较"></a>总结——C语言字符串和SDS字符串比较</h6><table>
<thead>
<tr>
<th align="left">C字符串</th>
<th align="left">Redis SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取字符串长度时间复杂的O(n)</td>
<td align="left">获取字符串长度时间复杂的O(1)</td>
</tr>
<tr>
<td align="left">字符串长度增加可能造成缓冲区溢出</td>
<td align="left">字符串长度增加不会造成缓冲区溢出</td>
</tr>
<tr>
<td align="left">修改字符串长度n次，必然n次内存重分配</td>
<td align="left">修改字符串长度n次，最多n次内存重分配</td>
</tr>
<tr>
<td align="left">只保存不含空格文本</td>
<td align="left">保存任意二进制数据和文本数据</td>
</tr>
<tr>
<td align="left">可以使用&lt;string.h&gt;库所有函数</td>
<td align="left">可以使用部分&lt;string.h&gt;库的函数</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(第10天lha命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/19/一天一个Linux命令(第10天lha命令)/">一天一个Linux命令(第10天lha命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/19/一天一个Linux命令(第10天lha命令)/" class="article-date">
	  <time datetime="2019-06-19T11:39:00.331Z" itemprop="datePublished">June 19, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MV命令"><a href="#MV命令" class="headerlink" title="MV命令"></a>MV命令</h2><ul>
<li>lha命令是从lharc演变而来的压缩程序，文件经它压缩后，会另外产生具有.lzh扩展名的压缩文件。</li>
</ul>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><pre><code>-a或a：压缩文件，并加入到压缩文件内。
-a&lt;0/1/2&gt;/u&lt;/0/1/2&gt;   压缩文件时，采用不同的文件头。
-c或c：压缩文件，重新建构新的压缩文件后，再将其加入。
-d或d：从压缩文件内删除指定的文件。
-&lt;a/c/u&gt;d或&lt;a/c/u&gt;d：压缩文件，然后将其加入，重新建构，更新压缩文件或，删除原始文件，也就是把文件移到压缩文件中。
-e或e：解开压缩文件。
-f或f：强制执行lha命令，在解压时会直接覆盖已有的文件而不加以询问。
-g或g：使用通用的压缩格式，便于解决兼容性的问题。
-&lt;e/x&gt;i或&lt;e/x&gt;i：解开压缩文件时，忽略保存在压缩文件内的文件路径，直接将其解压后存放在现行目录下或是指定的目录中。
-l或l：列出压缩文件的相关信息。
-m或m：此选项的效果和同时指定&quot;-ad&quot;选项相同。
-n或n：不执行指令，仅列出实际执行会进行的动作。
-&lt;a/u&gt;o或&lt;a/u&gt;o：采用lharc兼容格式，将压缩后的文件加入，更新压缩文件。
-p或p：从压缩文件内输出到标准输出设备。
-q或q：不显示指令执行过程。
-t或t：检查备份文件内的每个文件是否正确无误。
-u或u：更换较新的文件到压缩文件内。
-u&lt;/0/1/2&gt;或u&lt;/0/1/2&gt;：在文件压缩时采用不同的文件头，然后更新到压缩文件内。
-v或v：详细列出压缩文件的相关信息。
-&lt;e/x&gt;w=&lt;目的目录&gt;或&lt;e/x&gt;w=&lt;目的目录&gt;：指定解压缩的目录。
-x或x：解开压缩文件。
-&lt;a/u&gt;z或&lt;a/u&gt;z：不压缩文件，直接把它加入，更新压缩文件。</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>   压缩a.b文件，压缩后生成 abc.lhz 文件</p>
<pre><code>[fenglangjuxu@localhost /]$ lha -a abc.lhz a.b        </code></pre><p>   压缩目录 </p>
<pre><code>[fenglangjuxu@localhost /]$ lha -a abc2 /home/hnlinux  </code></pre><p>  解压文件abc，到当前目录</p>
<pre><code>[fenglangjuxu@localhost /]$ lha -xiw=agis abc         </code></pre>
      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-一天一个Linux命令(第9天zip命令)" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/06/19/一天一个Linux命令(第9天zip命令)/">一天一个Linux命令(第9天zip命令)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/19/一天一个Linux命令(第9天zip命令)/" class="article-date">
	  <time datetime="2019-06-19T11:38:59.966Z" itemprop="datePublished">June 19, 2019</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h2><ul>
<li>zip命令可以用来解压缩文件，或者对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>   <code>zip(选项)(参数)</code></p>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><pre><code>-A：调整可执行的自动解压缩文件；
-b&lt;工作目录&gt;：指定暂时存放文件的目录；
-c：替每个被压缩的文件加上注释；
-d：从压缩文件内删除指定的文件；
-D：压缩文件内不建立目录名称；
-f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；
-F：尝试修复已损坏的压缩文件；
-g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；
-h：在线帮助；
-i&lt;范本样式&gt;：只压缩符合条件的文件；
-j：只保存文件名称及其内容，而不存放任何目录名称；
-J：删除压缩文件前面不必要的数据；
-k：使用MS-DOS兼容格式的文件名称；
-l：压缩文件时，把LF字符置换成LF+CR字符；
-ll：压缩文件时，把LF+cp字符置换成LF字符；
-L：显示版权信息；
-m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；
-n&lt;字尾字符串&gt;：不压缩具有特定字尾字符串的文件；
-o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；
-q：不显示指令执行过程；
-r：递归处理，将指定目录下的所有文件和子目录一并处理；
-S：包含系统和隐藏文件；
-t&lt;日期时间&gt;：把压缩文件的日期设成指定的日期；
-T：检查备份文件内的每个文件是否正确无误；
-u：更换较新的文件到压缩文件内；
-v：显示指令执行过程或显示版本信息；
-V：保存VMS操作系统的文件属性；
-w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；
-x&lt;范本样式&gt;：压缩时排除符合条件的文件；
-X：不保存额外的文件属性；
-y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；
-z：替压缩文件加上注释；
-$：保存第一个被压缩文件所在磁盘的卷册名称；
-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值。</code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>zip压缩包：指定要创建的zip压缩包；</li>
<li>文件列表：指定要压缩的文件列表。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>   将/home/Blinux/html/这个目录下所有文件和文件夹打包为当前目录下的html.zip：</p>
<pre><code>[fenglangjuxu@localhost /]$ zip -q -r html.zip /home/Blinux/html</code></pre><p>  上面的命令操作是将绝对地址的文件及文件夹进行压缩，以下给出压缩相对路径目录，比如目前在Bliux这个目录下，执行以下操作可以达到以上同样的效果：</p>
<pre><code>[fenglangjuxu@localhost /]$ zip -q -r html.zip html</code></pre><p>   比如现在我的html目录下，我操作的zip压缩命令是：</p>
<pre><code>[fenglangjuxu@localhost /]$ zip -q -r html.zip *</code></pre>
      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/iTimeTraveler" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/07/17/一天一个Linux命令(date命令)/">一天一个Linux命令，date命令</a></h6>
              <span>July 17, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/07/16/一天一个Linux命令(look命令)/">一天一个Linux命令，look命令</a></h6>
              <span>July 16, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/07/15/一天一个Linux命令(hostname命令)/">一天一个Linux命令，hostname命令</a></h6>
              <span>July 15, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/07/13/一天一个Linux命令(type命令)/">一天一个Linux命令，type命令</a></h6>
              <span>July 13, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/07/12/Redis的五种对象类型及其底层实现/">Redis的五种对象类型及其底层实现</a></h6>
              <span>July 12, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/07/11/一天一个Linux命令(whereis命令)/">一天一个Linux命令，whereis命令</a></h6>
              <span>July 11, 2019</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">21</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 Hexo All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
